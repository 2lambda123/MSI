//Extra_WorldWalker_cstrike

{$IFDEF Extra_WorldWalker_cstrike}
{$IFDEF REFLECTION}

const
  // Axis offsets
  X_OFFSET = 0;
  Y_OFFSET = 0;
  // Node points
  VARROCKWESTBANK_X = 3186 + X_OFFSET;
  VARROCKWESTBANK_Y = 3439 + Y_OFFSET;
  FALADOREASTBANK_X = 3013 + X_OFFSET;
  FALADOREASTBANK_Y = 3356 + Y_OFFSET;
  LUMBRIDGENE_X = 3217 + X_OFFSET;
  LUMBRIDGENE_Y = 3251 + Y_OFFSET;
  DRAYNORBANK_X = 3094 + X_OFFSET;
  DRAYNORBANK_Y = 3242 + Y_OFFSET;
  BARBVILLAGEC_X = 3081 + X_OFFSET;
  BARBVILLAGEC_Y = 3416 + Y_OFFSET;

var NodeArray : TTileArray;
    currentTile : TTile; // This is the tile we're on
    VWB_LNE, VWB_BBC, // Highway variables
    BBC_VWB, BBC_FEB,
    DRB_LNE, DRB_FEB,
    LNE_DRB, LNE_VWB,
    FEB_DRB, FEB_BBC : TPointArray;
    Highway, SubStreet : T2DPointArray; // ATPA's

{******************************************************************************}
{ procedure SetupNodesAndPaths;                                                }
{ By: Cstrike                                                                  }
{ Description: Sets up node points and all arrays for program to function.     }
{******************************************************************************}
procedure SetupNodesAndPaths;
begin
  NodeArray := [Tile (VARROCKWESTBANK_X, VARROCKWESTBANK_Y), // 0 Varrock west bank
                Tile (FALADOREASTBANK_X, FALADOREASTBANK_Y), // 1 Fally east bank
                Tile (LUMBRIDGENE_X, LUMBRIDGENE_Y), // 2 Lumby NE
                Tile (DRAYNORBANK_X, DRAYNORBANK_Y), // 3 Draynor bank
                Tile (BARBVILLAGEC_X, BARBVILLAGEC_Y)]; // 4 Barb village center (S of dungeon)
  // Node highway travel only
  VWB_LNE := [Point(3186, 3439),
              Point(3194, 3429), Point(3207, 3428), Point(3211, 3415),
              Point(3211, 3400), Point(3211, 3386), Point(3213, 3372),
              Point(3218, 3359), Point(3226, 3347), Point(3228, 3337),
              Point(3240, 3336), Point(3240, 3326), Point(3240, 3312),
              Point(3239, 3302), Point(3239, 3294), Point(3239, 3282),
              Point(3241, 3275), Point(3241, 3264), Point(3227, 3261),
              Point(3217, 3257), Point(3219, 3247),
              Point(LUMBRIDGENE_X, LUMBRIDGENE_Y)];
  VWB_BBC := [Point(3180, 3429),
              Point(3169, 3428), Point(3163, 3421), Point(3151, 3417),
              Point(3140, 3417), Point(3129, 3416), Point(3120, 3418),
              Point(3111, 3420), Point(3099, 3420), Point(3089, 3419),
              Point(BARBVILLAGEC_X, BARBVILLAGEC_Y)];
  BBC_VWB := [Point (3089,3419),
              Point (3099,3420), Point (3111,3420), Point (3120,3418),
              Point (3129,3416), Point (3140,3417), Point (3151,3417),
              Point (3163,3421), Point (3169,3428), Point (3180,3429),
              Point(VARROCKWESTBANK_X, VARROCKWESTBANK_Y)];
  BBC_FEB := [Point (3075,3419),
              Point (3064,3417), Point (3054,3415), Point (3044,3419),
              Point (3032,3426), Point (3020,3428), Point (3010,3431),
              Point (3002,3431), Point (2989,3429), Point (2986,3419),
              Point (2978,3412), Point (2971,3402), Point (2965,3389),
              Point (2969,3379), Point (2983,3376), Point (2993,3368),
              Point (3004,3363), Point (FALADOREASTBANK_X, FALADOREASTBANK_Y)];
  DRB_LNE := [Point (3098,3235),
              Point (3100,3230), Point (3110,3229), Point (3119,3228),
              Point (3125,3225), Point (3133,3227), Point (3141,3229),
              Point (3147,3235), Point (3157,3235), Point (3165,3238),
              Point (3171,3239), Point (3176,3245), Point (3180,3247),
              Point (3185,3245), Point (3193,3246), Point (3200,3247),
              Point (3208,3246), Point (3212,3246),
              Point(LUMBRIDGENE_X, LUMBRIDGENE_Y)];
  DRB_FEB := [Point(3086, 3249),
              Point(3080, 3256), Point(3073, 3266), Point(3072, 3276),
              Point(3064, 3277), Point(3050, 3275), Point(3039, 3276),
              Point(3031, 3278), Point(3021, 3276), Point(3010, 3278),
              Point(3005, 3287), Point(3006, 3298), Point(3006, 3311),
              Point(3006, 3320), Point(3007, 3331), Point(3008, 3345),
              Point(3006, 3356), Point (FALADOREASTBANK_X, FALADOREASTBANK_Y)];
  LNE_DRB := [Point(3214, 3246),
              Point(3208, 3246), Point(3200, 3247), Point(3193, 3246),
              Point(3185, 3245), Point(3180, 3247), Point(3176, 3245),
              Point(3171, 3239), Point(3165, 3238), Point(3157, 3235),
              Point(3147, 3235), Point(3141, 3229), Point(3133, 3227),
              Point(3125, 3225), Point(3119, 3228), Point(3110, 3229),
              Point(3100, 3230), Point(3098, 3235),
              Point(DRAYNORBANK_X, DRAYNORBANK_Y)];
  LNE_VWB := [Point (3223,3237),
              Point (3219,3247), Point (3217,3257), Point (3227,3261),
              Point (3241,3264), Point (3241,3275), Point (3239,3282),
              Point (3239,3294), Point (3239,3302), Point (3240,3312),
              Point (3240,3326), Point (3240,3336), Point (3228,3337),
              Point (3226,3347), Point (3218,3359), Point (3213,3372),
              Point (3211,3386), Point (3211,3400), Point (3211,3415),
              Point (3207,3428), Point (3194,3429), Point (3186,3439),
              Point (VARROCKWESTBANK_X, VARROCKWESTBANK_Y)];
  FEB_DRB := [Point (3006,3356),
              Point (3008,3345), Point (3007,3331), Point (3006,3320),
              Point (3006,3311), Point (3006,3298), Point (3005,3287),
              Point (3010,3278), Point (3021,3276), Point (3031,3278),
              Point (3039,3276), Point (3050,3275), Point (3064,3277),
              Point (3072,3276), Point (3073,3266), Point (3080,3256),
              Point (3086,3249), Point (DRAYNORBANK_X, DRAYNORBANK_Y)];
  FEB_BBC := [Point(3004, 3363),
              Point(2993, 3368), Point(2983, 3376), Point(2969, 3379),
              Point(2965, 3389), Point(2971, 3402), Point(2978, 3412),
              Point(2986, 3419), Point(2989, 3429), Point(3002, 3431),
              Point(3010, 3431), Point(3020, 3428), Point(3032, 3426),
              Point(3044, 3419), Point(3054, 3415), Point(3064, 3417),
              Point(3075, 3419), Point(BARBVILLAGEC_X, BARBVILLAGEC_Y)];
  // Highway
  SetArrayLength (Highway, 5); //Priority: FEB = VWB > DRB > LMB > BBC
  Highway[0] :=[Point(BARBVILLAGEC_X, BARBVILLAGEC_Y), Point (3089,3419), // Barb vil to varrock west bank
                Point (3099,3420), Point (3111,3420), Point (3120,3418),
                Point (3129,3416), Point (3140,3417), Point (3151,3417),
                Point (3163,3421), Point (3169,3428), Point (3180,3429),
                Point(VARROCKWESTBANK_X, VARROCKWESTBANK_Y)];
  Highway[1] :=[Point(LUMBRIDGENE_X, LUMBRIDGENE_Y),  // Lumby northeast to varrock west bank (tiles[1..2] (note, not tiles[0]) were fucked up, check them)
                Point (3217,3257), Point (3227,3261),
                Point (3241,3264), Point (3241,3275), Point (3239,3282),
                Point (3239,3294), Point (3239,3302), Point (3240,3312),
                Point (3240,3326), Point (3240,3336), Point (3228,3337),
                Point (3226,3347), Point (3218,3359), Point (3213,3372),
                Point (3211,3386), Point (3211,3400), Point (3211,3415),
                Point (3207,3428), Point (3194,3429),
                Point (VARROCKWESTBANK_X, VARROCKWESTBANK_Y)];
  Highway[2] :=[Point(BARBVILLAGEC_X, BARBVILLAGEC_Y), Point (3075,3419), // barb vil to fally east bank
                Point (3064,3417), Point (3054,3415), Point (3044,3419),
                Point (3032,3426), Point (3020,3428), Point (3010,3431),
                Point (3002,3431), Point (2989,3429), Point (2986,3419),
                Point (2978,3412), Point (2971,3402), Point (2965,3389),
                Point (2969,3379), Point (2983,3376), Point (2993,3368),
                Point (3004,3363), Point (FALADOREASTBANK_X, FALADOREASTBANK_Y)];
  Highway[3] :=[Point (DRAYNORBANK_X, DRAYNORBANK_Y), Point(3086, 3249), // draynor bank to fally east bank
                Point(3080, 3256), Point(3073, 3266), Point(3072, 3276),
                Point(3064, 3277), Point(3050, 3275), Point(3039, 3276),
                Point(3031, 3278), Point(3021, 3276), Point(3010, 3278),
                Point(3005, 3287), Point(3006, 3298), Point(3006, 3311),
                Point(3006, 3320), Point(3007, 3331), Point(3008, 3345),
                Point(3006, 3356), Point (FALADOREASTBANK_X, FALADOREASTBANK_Y)];
  Highway[4] :=[Point(LUMBRIDGENE_X, LUMBRIDGENE_Y), Point(3214, 3246), // lumby to draynor bank
                Point(3208, 3246), Point(3200, 3247), Point(3193, 3246),
                Point(3185, 3245), Point(3180, 3247), Point(3176, 3245),
                Point(3171, 3239), Point(3165, 3238), Point(3157, 3235),
                Point(3147, 3235), Point(3141, 3229), Point(3133, 3227),
                Point(3125, 3225), Point(3119, 3228), Point(3110, 3229),
                Point(3100, 3230), Point(3098, 3235), Point(DRAYNORBANK_X, DRAYNORBANK_Y)];
  //Streets
  SetArrayLength (SubStreet, 27);
  // These paths are between the >60 west of draynor guarded gate, and lumbyNE node
  SubStreet[0] := [Point(3094, 3242), Point(3100, 3244), Point(3105, 3247), // √ Inside draynor village to draynor bank
                   Point(3104, 3257), Point(3102, 3262), Point(3092, 3259)];
  SubStreet[1] := [Point(3110, 3229), Point(3114, 3220), Point(3117, 3212), // √ Wiz tower from below draynor bank path
                   Point(3114, 3205), Point(3113, 3196), Point(3113, 3187),
                   Point(3113, 3181), Point(3113, 3171), Point(3110, 3167),
                   Point(3102, 3165), Point(3101, 3155), Point(3105, 3150)];
  SubStreet[2] := [Point(3133, 3227), Point(3136, 3218), Point(3138, 3208), // √ Follows western sea that arcs around the two lumby mines, and ends at the lumby mine with addy/mith at the SE corner [south of lumby]
                   Point(3141, 3203), Point(3141, 3193), Point(3144, 3184),
                   Point(3143, 3177), Point(3146, 3167), Point(3148, 3158),
                   Point(3151, 3149), Point(3159, 3147), Point(3168, 3150),
                   Point(3177, 3150), Point(3186, 3148), Point(3196, 3148),
                   Point(3202, 3152), Point(3212, 3151), Point(3222, 3150),
                   Point(3234, 3150)];
  SubStreet[3] := [Point(3133, 3227), Point(3137, 3218), Point(3143, 3213), // √ Goes from south of jail, to hook around the north of the swamp below lumbridge
                   Point(3148, 3206), Point(3154, 3202), Point(3161, 3197),
                   Point(3174, 3197), Point(3185, 3195), Point(3197, 3190),
                   Point(3202, 3185), Point(3212, 3184), Point(3219, 3176)];
  SubStreet[4] := [Point(3098, 3235), Point(3092, 3228), Point(3091, 3217), // South of draynor bank
                   Point(3101, 3211)];
  SubStreet[5] := [Point(3072, 3276), Point(3074, 3287), Point(3072, 3297), // √ Hooks north of the draynor market, and goes up to the west of draynor manor (without passing over the walls, and then hooks southeast slightly into the forest
                   Point(3072, 3307), Point(3076, 3314), Point(3078, 3323),
                   Point(3088, 3322), Point(3092, 3312)];
  SubStreet[6] := [Point(3072, 3276), Point(3077, 3281), Point(3086, 3289), // √ Goes east of the draynor/south fally gate >60 total guys, follows the path to the 4 way cross, goes up to draynor manor and hooks around the right side, ending on the bottom left of the draynor manor near some grey patch
                   Point(3094, 3291), Point(3102, 3294), Point(3109, 3297),
                   Point(3113, 3303), Point(3113, 3310), Point(3111, 3318),
                   Point(3111, 3327), Point(3110, 3339), Point(3109, 3346),
                   Point(3115, 3351), Point(3123, 3351), Point(3128, 3356),
                   Point(3128, 3364), Point(3125, 3373), Point(3116, 3376),
                   Point(3109, 3376), Point(3096, 3376), Point(3091, 3374),
                   Point(3087, 3365), Point(3087, 3357), Point(3086, 3348),
                   Point(3090, 3338)];
  SubStreet[7] := [Point(3157, 3235), Point(3157, 3227), Point(3160, 3221), // South of ham in lumby-west, between two trees, really close to the water symbol
                   Point(3167, 3212), Point(3175, 3210)];
  SubStreet[8] := [Point(3157, 3235), Point(3152, 3243), Point(3143, 3253), // Runs east of the jail up by the grains and continues up to the right of draynor mansion, stopping before this hole in the white wall east of the manor
                   Point(3135, 3262), Point(3134, 3275), Point(3134, 3288),
                   Point(3134, 3300), Point(3136, 3311), Point(3141, 3320),
                   Point(3145, 3329), Point(3147, 3333)];
  SubStreet[9] := [Point(3176, 3245), Point(3172, 3252), Point(3164, 3257), //East around ham building, north in front of windmill/grain thing, and then a tile west of that as the last additional added tile
                   Point(3163, 3263), Point(3161, 3271), Point(3162, 3278),
                   Point(3163, 3287), Point(3166, 3293), Point(3167, 3301),
                   Point(3159, 3310)];
  SubStreet[10] :=[Point(3176, 3245), Point(3180, 3232), Point(3182, 3226), // south past the right set of rare trees (west of farming patch) so the southwest side of the lumby castle (outside the walls), does not go under the castle
                   Point(3185, 3218), Point(3186, 3210), Point(3194, 3204),
                   Point(3198, 3200)];
  SubStreet[11] :=[Point(3176, 3245), Point(3179, 3251), Point(3180, 3258), // east of HAM to the west side of the sheep shearer's farm place
                   Point(3181, 3267)];
  SubStreet[12] :=[Point(3133, 3227), Point(3130, 3235), Point(3132, 3242), // runs up through the bottom of the jail and hooks around the north from the east, to the west
                   Point(3130, 3248), Point(3119, 3251)];
  SubStreet[13] :=[Point(3133, 3227), Point(3139, 3223), Point(3143, 3217), // Walks south of that irritating wall that seperates lumby forest from lumby swamps, remember... walks south of the wall and retrieves to the brown path
                   Point(3146, 3211), Point(3153, 3209), Point(3160, 3203),
                   Point(3172, 3203), Point(3184, 3202), Point(3191, 3197),
                   Point(3199, 3194), Point(3208, 3194)];
  SubStreet[14] :=[Point(3217, 3251), Point(3222, 3242), Point(3225, 3235), // Walk from lumbyNE node down the path through graveyard to just east of the mining spot with addy
                   Point(3231, 3230), Point(3236, 3225), Point(3237, 3216),
                   Point(3237, 3202), Point(3243, 3199), Point(3245, 3190),
                   Point(3243, 3180), Point(3239, 3169), Point(3241, 3159),
                   Point(3237, 3147)];
  SubStreet[15] :=[Point(3217, 3251), Point(3221, 3243), Point(3224, 3235), // Goes from LNE node into lumby castle, and inside right to outside the cooks door/near south spiral ladder
                   Point(3232, 3227), Point(3234, 3218), Point(3225, 3216),
                   Point(3215, 3217), Point(3214, 3209), Point(3207, 3208)];
  SubStreet[16] :=[Point(3217, 3257), Point(3217, 3265), Point(3215, 3274), // takes the first tile in the path that goes from LNE->VWB
                   Point(3210, 3278), Point(3197, 3278), Point(3190, 3285),
                   Point(3189, 3294), Point(3188, 3302), Point(3185, 3308),
                   Point(3177, 3313)];
  // These paths are between 'east of lumby bridge(s) and varrock west bank
  SubStreet[17] :=[Point(3207, 3428), Point(3216, 3426), Point(3223, 3430),
                   Point(3232, 3431), Point(3241, 3429), Point(3254, 3429),
                   Point(3254, 3420)]; // Varrock east bank
  SubStreet[18] :=[Point(3207, 3428), Point(3216, 3425), Point(3223, 3429),
                   Point(3237, 3430), Point(3249, 3430), Point(3262, 3429),
                   Point(3271, 3429), Point(3279, 3430), Point(3287, 3424),
                   Point(3288, 3414), Point(3291, 3409), Point(3292, 3401),
                   Point(3293, 3393), Point(3294, 3385), Point(3293, 3377),
                   Point(3288, 3373), Point(3286, 3367)]; // Varrock southEast mines
  SubStreet[24] := [Point(3207, 3428), Point(3208, 3434), Point(3213, 3438),
                    Point(3213, 3446), Point(3206, 3452), Point(3200, 3458),
                    Point(3197, 3466), Point(3197, 3476), Point(3196, 3484),
                    Point(3197, 3493), Point(3196, 3499), Point(3201, 3504),
                    Point(3211, 3502), Point(3219, 3502), Point(3228, 3500),
                    Point(3231, 3488), Point(3230, 3480)]; // Goes near varrock fountain, then up and around the castle, hooking around the west side, past the yews in the north, and then into the queens garden on the east side
  // These paths are between BBC and varrock west bank
  SubStreet[19] :=[Point(3169, 3428), Point(3171, 3421), Point(3171, 3412),
                   Point(3171, 3403), Point(3171, 3395), Point(3174, 3389),
                   Point(3177, 3384), Point(3175, 3377), Point(3170, 3369),
                   Point(3173, 3363), Point(3181, 3367)]; // Varrock southWest mine near champion guild
  SubStreet[20] :=[Point(3186, 3439), Point(3186, 3445), Point(3184, 3451),
                   Point(3175, 3452), Point(3170, 3456), Point(3164, 3465),
                   Point(3164, 3473), Point(3164, 3479), Point(3165, 3487)]; // Grand exchange
  SubStreet[21] :=[Point(3089, 3419), Point(3086, 3426), Point(3089, 3435),
                   Point(3087, 3444), Point(3087, 3450), Point(3090, 3457),
                   Point(3088, 3460), Point(3087, 3466), Point(3082, 3467),
                   Point(3080, 3477), Point(3080, 3485), Point(3086, 3490),
                   Point(3093, 3493)]; // Edgeville
  // These paths are between falador east bank and BBC

  // These paths are between fally and draynor >60 level guards
  SubStreet[22] :=[Point(3010, 3278), Point(3008, 3272), Point(2998, 3270),
                   Point(2990, 3270), Point(2983, 3265), Point(2978, 3262),
                   Point(2977, 3253), Point(2977, 3241)]; // Fally south (corner of farm) going to rimmington mining field
  SubStreet[23] :=[Point(3039, 3276), Point(3039, 3268), Point(3038, 3261),
                   Point(3040, 3255), Point(3041, 3247), Point(3042, 3235),
                   Point(3048, 3235)]; // Slightly SE of the opening to the farm, heads almost straight down to the port and then over to the port sarim dropoff box approximately
  SubStreet[25] :=[Point(3064, 3277), Point(3062, 3271), Point(3059, 3266),
                   Point(3059, 3260), Point(3060, 3253)]; // West of lvl 60 gate, immediately goes south and over farming patch to the trees near the sea
  SubStreet[26] :=[Point(3010, 3278), Point(3002, 3277), Point(2997, 3278),
                   Point(2990, 3278), Point(2985, 3276), Point(2980, 3273),
                   Point(2978, 3268), Point(2974, 3262), Point(2968, 3257),
                   Point(2964, 3253), Point(2957, 3244), Point(2953, 3241),
                   Point(2946, 3239), Point(2943, 3231), Point(2939, 3227),
                   Point(2934, 3220), Point(2932, 3215), Point(2924, 3215),
                   Point(2922, 3207), Point(2927, 3202), Point(2934, 3199)]; // Fally crossroads SW of farm, follows path all the way down to the chemist/distiller, then goes west and hooks around to the south
end;

// Output's the TPA for debug purposes
procedure DebugTheTPA (TPA : TPointArray);
var i : Integer;
begin
  writeln ('TPA debug:');
  for i:=0 to high(TPA) do
  begin
  writeln ('['+inttostr(i)+']: Point ('+inttostr(TPA[i].x)+','+inttostr(TPA[i].y)+')');
  end;
end;

// Output's the TTA for debug purposes
procedure DebugTheTTA (TTA : TTileArray);
var i : Integer;
begin
  writeln ('TTA debug:');
  for i:=0 to high(TTA) do
  begin
  writeln ('['+inttostr(i)+']: Tile ('+inttostr(TTA[i].x)+','+inttostr(TTA[i].y)+')');
  end;
end;

//Easy code for a current position output
procedure DebugCurrentPos;
begin
  currentTile := GetMyPos;
  writeln ('DEBUG_CURRENT_TILE: Current tile = ('+inttostr(currentTile.x)+','+inttostr(currentTile.y)+')');
end;

{******************************************************************************}
{ procedure AddTPAToTTA (TPA : TPointArray; var T_TileArray : TTileArray);     }
{ By: Cstrike                                                                  }
{ Description: Create TTileArray from TPA                                      }
{******************************************************************************}
procedure AddTPAToTTA (TPA : TPointArray; var T_TileArray : TTileArray);
var i, j, originalHighTTA : Integer;
begin
  j:=0;
  originalHighTTA := high(T_TileArray)
  SetArrayLength (T_TileArray, (high(TPA)+high(T_TileArray)+2));
  for i:=originalHighTTA+1 to (originalHighTTA+high(TPA))+1 do
  begin
    T_TileArray[i] := Tile(TPA[j].x,TPA[j].y);
    Inc(j);
  end;
end;

{******************************************************************************}
{ procedure AddTPAFromDownToTTA (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray); }
{ By: Cstrike                                                                  }
{ Description: A shofrter version of CreateTPADownFromFragment (below), may    }
{ screw up occasionally, don't know why. Must debug this.                      }
{******************************************************************************}
procedure AddTPAFromDownToTTA (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray);
var i : Integer;
begin
  SetArrayLength (TPA, TPAPos+1);
  for i:=TPAPos downto 0 do
  begin
    TPA[i] := ATPA[ATPAPos][i];
  end;
  InvertTPA (TPA);
end;

{******************************************************************************}
{ procedure CreateTPAUpFromFragment (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray); }
{ By: Cstrike                                                                  }
{ Description: Stores a TPA from an ATPA's TPA position up until high(TPA)     }
{ Ex: If you have a TPA in an ATPA from 0 to 20, and want to create TPA#2 from }
{     TPA position 16 to 20, you would enter TPAPos as 16. ATPAPos is just the }
{     index of what TPA in the ATPA you're looking for (aka, ATPA[ATPAPos])    }
{******************************************************************************}
procedure CreateTPAUpFromFragment (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray);
var initial, i, highATPA, TPADifference : Integer;
begin
  initial := 0; // This is so the new TPA we create starts from zero, because every time I try using 'i', it ends up being something thats not zero, screwing it all up. So I just made my own variable for starting at zero
  highATPA := High(ATPA[ATPAPos]);
  TPADifference := (highATPA-TPAPos);
  SetArrayLength (TPA, TPADifference+1);
  for i:=TPAPos to highATPA do
  begin
    TPA[initial] := ATPA[ATPAPos][i];
    Inc(initial); // Now that we've set TPA, lets increase it for next time... if it exceeds it... no big deal because it will end the loop before creating a new TPA point
  end;
end;

{******************************************************************************}
{ procedure CreateTPAUpFromFragmentInvert (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray); }
{ By: Cstrike                                                                  }
{ Description: Stores a TPA from an ATPA's TPA position up until high(TPA)     }
{ Ex: If you have a TPA in an ATPA from 0 to 20, and want to create TPA#2 from }
{     TPA position 16 to 20, you would enter TPAPos as 16. ATPAPos is just the }
{     index of what TPA in the ATPA you're looking for (aka, ATPA[ATPAPos])    }
{     It is considered "Invert" because at the end it inverts the TPA fragment }
{     which is useful for when you are using WalkTo. When you are retrieving   }
{     to a bank, you don't need to invert because it will always have the end  }
{     tile as being the bank node, but if you try and use this while walking   }
{     to a branch point (to branch off on a subpath to get near your TPoint),  }
{     the other function will make it so that it will always make you return   }
{     to a node point. Thus, invert makes you walk in the opposite direction   }
{     from a node point to your branch-off-from-the-highway-point              }
{******************************************************************************}
procedure CreateTPAUpFromFragmentInvert (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray);
var initial, i, highATPA, TPADifference : Integer;
begin
  initial := 0; // This is so the new TPA we create starts from zero, because every time I try using 'i', it ends up being something thats not zero, screwing it all up. So I just made my own variable for starting at zero
  highATPA := High(ATPA[ATPAPos]);
  TPADifference := (highATPA-TPAPos);
  SetArrayLength (TPA, TPADifference+1);
  for i:=TPAPos to highATPA do
  begin
    TPA[initial] := ATPA[ATPAPos][i];
    Inc(initial); // Now that we've set TPA, lets increase it for next time... if it exceeds it... no big deal because it will end the loop before creating a new TPA point
  end;
  InvertTPA (TPA);
end;

{******************************************************************************}
{ procedure CreateTPADownFromFragment (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray); }
{ By: Cstrike                                                                  }
{ Description: Stores a TPA from an ATPA's TPA position down until TPA[0]      }
{ Ex: If you have a TPA in an ATPA from 0 to 20, and want to create TPA#2 from }
{     TPA position 7 to 0 (NOT from 0 to 7!), you would enter TPAPos as 7.     }
{     ATPAPos is just the index of what TPA in the ATPA you're looking for     }
{     (aka, ATPA[ATPAPos])                                                     }
{******************************************************************************}
procedure CreateTPADownFromFragment (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray);
var initial, i, highATPA, TPADifference : Integer;
begin
  initial := 0; // This is so the new TPA we create starts from zero, because every time I try using 'i', it ends up being something thats not zero, screwing it all up. So I just made my own variable for starting at zero
  highATPA := High(ATPA[ATPAPos]);
  TPADifference := (highATPA-TPAPos);
  SetArrayLength (TPA, TPAPos+1);
  writeln ('TPADif = ' +inttostr(TPADifference));
  for i:=TPAPos downto 0 do // Start from our TPA position (lets say were 7 of 20, start at position 7), and then go down to position zero
  begin
    TPA[initial] := ATPA[ATPAPos][i];
    Inc(initial); // Now that we've set TPA, lets increase it for next time... if it exceeds it... no big deal because it will end the loop before creating a new TPA point
  end;
end;

{******************************************************************************}
{ procedure CreateTPADownFromFragmentInvert (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray); }
{ By: Cstrike                                                                  }
{ Description: Stores a TPA from an ATPA's TPA position down until TPA[0]      }
{ Ex: If you have a TPA in an ATPA from 0 to 20, and want to create TPA#2 from }
{     TPA position 7 to 0 (NOT from 0 to 7!), you would enter TPAPos as 7.     }
{     ATPAPos is just the index of what TPA in the ATPA you're looking for     }
{     (aka, ATPA[ATPAPos]). Inverts at the end (see CTPAUFFInvert for details) }
{     (aka, does from 0 to 7 ;) ...)                                           }
{******************************************************************************}
procedure CreateTPADownFromFragmentInvert (ATPA : T2DPointArray; ATPAPos, TPAPos : Integer; var TPA : TPointArray);
var initial, i, highATPA, TPADifference : Integer;
begin
  initial := 0; // This is so the new TPA we create starts from zero, because every time I try using 'i', it ends up being something thats not zero, screwing it all up. So I just made my own variable for starting at zero
  highATPA := High(ATPA[ATPAPos]);
  TPADifference := (highATPA-TPAPos);
  SetArrayLength (TPA, TPAPos+1);
  writeln ('TPADif = ' +inttostr(TPADifference));
  for i:=TPAPos downto 0 do // Start from our TPA position (lets say were 7 of 20, start at position 7), and then go down to position zero
  begin
    TPA[initial] := ATPA[ATPAPos][i];
    Inc(initial); // Now that we've set TPA, lets increase it for next time... if it exceeds it... no big deal because it will end the loop before creating a new TPA point
  end;
  InvertTPA (TPA);
end;

{******************************************************************************}
{ procedure RemoveTPFromTPA (TPA : TPointArray; Index : Integer);              }
{ By: Cstrike                                                                  }
{ Description: Removes TPA[Index] and truncates TPA that you input             }
{******************************************************************************}
procedure RemoveTPFromTPA (TPAToRemoveFrom, ModifiedTPA : TPointArray; Index : Integer);
var i, j : Integer;
begin
  j := 0;
  if Index > High(TPAToRemoveFrom) then
  begin
    writeln ('Warning, index greater than what TPA has, setting new TPA to old TPA');
    ModifiedTPA := TPAToRemoveFrom;
    Exit;
  end;
  for i:=0 to high(TPAToRemoveFrom) do
  begin
    SetArrayLength (ModifiedTPA,high(TPAToRemoveFrom));
    if i <> index then
      begin
        ModifiedTPA[j] := TPAToRemoveFrom[i];
        writeln ('J = '+inttostr(j));
        //DebugTheTPA (ModifiedTPA);
        Inc(j);
      end;
  end;
  writeln ('RemoveTPFromTPA result:');
  DebugTheTPA (ModifiedTPA);
end;

{******************************************************************************}
{ function TMin (TIA : TIntegerArray) : Integer;                               }
{ By: Cstrike                                                                  }
{ Description: Sets TIA[0] as the lowest number                                }
{******************************************************************************}
function TMin (TIA : TIntegerArray) : Integer;
begin
  QuickSort (TIA);
  if high(TIA) > 0 then result := TIA[0] else result := 0;
end;

{******************************************************************************}
{ procedure FindTPInATPA (TP : TPoint; ATPA : T2DPointArray; var ATPAPos, TPAPos : Integer); }
{ By: Cstrike                                                                  }
{ Description: Searches an ATPA for a TPoint. Returns the ATPA index and the   }
{ TPA index of where the TPoint is located. Only returns one position, which   }
{ is the last one it will find                                                 }
{******************************************************************************}
procedure FindTPInATPA (TP : TPoint; ATPA : T2DPointArray; var ATPAPos, TPAPos : Integer);
var i, j : integer;
begin
  if not LoggedIn then exit;
  writeln ('Debugging: Requested to find Point('+inttostr(TP.x)+','+inttostr(TP.y)+') in an ATPA');
  ATPAPos := 0;
  TPAPos := 0;
  for i:=0 to high(ATPA) do
  begin
    for j:=0 to high(ATPA[i]) do
    begin
      if ATPA[i][j] = TP then
      begin
        ATPAPos := i;
        writeln ('ATPApos = '+inttostr(i));
        TPAPos := j;
        writeln ('TPApos = '+inttostr(j));
      end;
    end;
  end;
end;

{******************************************************************************}
{ function FindPathToTile (TP : TPoint; walkRadius : Integer) : Boolean;       }
{ By: Cstrike                                                                  }
{ Description: Attemps to walk (blindly) towards the TPoint (or TTile, since   }
{ the TPoint is converted). X increases as you go east, Y as you go north.     }
{ Needs serious code fixing, but it works. WalkRadius is how many tiles it     }
{ will walk in each increment. Shouldn't use a radius that is larger than      }
{ the minimap. Should not use zero, try and keep it between 2 and 12.          }
{******************************************************************************}
function FindPathToTile (TP : TPoint; walkRadius : Integer) : Boolean;
var currentTile, walkTile, desiredTile : TTile;
    i, hyp, increments, cx, cy, xincI, yincI : Integer;
    xinc, yinc : Extended;
begin
  if not LoggedIn then exit;
  if walkRadius < 1 then // If human is stupid then
  begin
    writeln ('Warning, walkRadius < 1, exiting...');
    result := false;
    exit;
  end;
  currentTile := GetMyPos;
  writeln ('current tile ('+inttostr(currentTile.x)+','+inttostr(currentTile.y)+')');
  desiredTile := PointToTile (TP);
  writeln ('desired point ('+inttostr(TP.x)+','+inttostr(TP.y)+')');
  hyp := Distance (currentTile.x, currentTile.y, TP.x, TP.y);
  writeln ('hypotenuse = ' + inttostr(hyp));
  increments := round(hyp/walkRadius);
  writeln ('increments = '+inttostr(increments));
  if increments > 0 then
  begin
    xinc := ((currentTile.x - TP.x)/increments);
    yinc := ((currentTile.y - TP.y)/increments);
    xinc := abs (xinc);
    yinc := abs (yinc);
    xincI := round (xinc);
    yincI := round (yinc);
    writeln ('x incs = '+floattostr(xinc));
    writeln ('y incs = '+floattostr(yinc));
    cx := currentTile.x;
    cy := currentTile.y;
    if (currentTile.x <= TP.x) and (currentTile.y <= TP.y) then
    begin
      writeln ('current tile x < TP.x, currentTile.y < TP.y');
      for i:=0 to increments-1 do
      begin
        cx := cx + xincI;
        cy := cy + yincI;
        walkTile := Tile (cx, cy);
        WalkToTile (walkTile, 0, 1); // BOOLEAN FALSE
      end;
    end else
    if (currentTile.x >= TP.x) and (currentTile.y <= TP.y) then
    begin
      writeln ('current tile x > TP.x, currentTile.y < TP.y');
      for i:=0 to increments-1 do
      begin
        cx := cx - xincI;
        cy := cy + yincI;
        walkTile := Tile (cx, cy);
        WalkToTile (walkTile, 0, 1); // BOOLEAN FALSE
      end;
    end else
    if (currentTile.x <= TP.x) and (currentTile.y >= TP.y) then
    begin
      writeln ('current tile x < TP.x, currentTile.y > TP.y');
      for i:=0 to increments-1 do
      begin
        cx := cx + xincI;
        cy := cy - yincI;
        walkTile := Tile (cx, cy);
        WalkToTile (walkTile, 0, 1); // BOOLEAN FALSE
      end;
    end else
    if (currentTile.x >= TP.x) and (currentTile.y >= TP.y) then
    begin
      writeln ('current tile x > TP.x, currentTile.y > TP.y');
      for i:=0 to increments-1 do
      begin
        cx := cx - xincI;
        cy := cy - yincI;
        walkTile := Tile (cx, cy);
        WalkToTile (walkTile, 0, 1); // BOOLEAN FALSE
      end;
    end;
  end else // If increments = 0
  begin
    result := true;
    writeln ('No need to use PathFinder, were in TPA range');
  end;
  if TileOnMM (desiredTile) then
  begin
    writeln ('Good news, tile is on minimap!');
    result := true;
  end else
  if not TileOnMM (desiredTile) then
  begin
    writeln ('Tile is NOT on the minimap');
    result := false;
  end;
end;

{******************************************************************************}
{ function SubPointDistances (ATPA : T2DPointArray) : TPoint;                  }
{ By: Cstrike                                                                  }
{ Description: Returns TPoint from ATPA which is closest to current position   }
{******************************************************************************}
function SubPointDistances (ATPA : T2DPointArray) : TPoint;
var distArrLowest, tempdistArrLowest, distTPAInt, tempdistTPATInt : TIntegerArray;
    distArrLowestTP : TPointArray;
    currentTile : TTile;
    i, j, k, z : Integer;
begin
  if not LoggedIn then exit;
  currentTile := GetMyPos; // Don't remove this, it's needed
  writeln ('SubPointDist: Current tile = ('+inttostr(currentTile.x)+','+inttostr(currentTile.y)+')');
  writeln ('high(ATPA) = ' + inttostr(high(ATPA)));
  SetArrayLength (distArrLowest, high(ATPA)+1); // The array that holds all the *smallest* distances from each TPA
  SetArrayLength (tempdistArrLowest, high(ATPA)+1);
  SetArrayLength (distArrLowestTP, high(ATPA)+1);
  for i:=0 to high(ATPA) do // For the entire ATPA do...
  begin
    //writeln ('high(ATPA)[i] = ' + inttostr(high(ATPA[i])));
    SetArrayLength (distTPAInt, high(ATPA[i])+1);
    SetArrayLength (tempdistTPATInt, high(ATPA[i])+1);
    for j:=0 to high(ATPA[i]) do // For each TPA in ATPA do...
    begin
      distTPAInt[j] := Distance (currentTile.x, currentTile.y, ATPA[i][j].x, ATPA[i][j].y);
      tempdistTPATInt[j] := Distance (currentTile.x, currentTile.y, ATPA[i][j].x, ATPA[i][j].y);
      //DEBUGDEBUGwriteln ('ATPA['+inttostr(i)+']['+inttostr(j)+'] distance = '+inttostr(distTPAInt[j])+' ('+inttostr(ATPA[i][j].x)+','+inttostr(ATPA[i][j].y)+')'); // Debug
      if j = high(ATPA[i]) then // When we reach the top of our TPA, do the following [only because I cant do this outside the for loop...]
      begin
        TMin (tempdistTPATInt); // Return the integer thats the SMALLEST distance from the TIntegerArray
        writeln ('Minimum distance (tempdistTPAInt[0])= '+inttostr(tempdistTPATInt[0]));
        distArrLowest[i] := tempdistTPATInt[0];
        tempdistArrLowest[i] := tempdistTPATInt[0];
        for k:=0 to high(ATPA[i]) do // This goes back and gives us the TPoint that matches up with the smallest distance, and stores it in an array for future decisions
        begin
          if distArrLowest[i] = distTPAInt[k] then
          begin
            distArrLowestTP[i] := ATPA[i][k];
            //writeln ('distArrLowestTP['+inttostr(i)+'] = ('+inttostr(distArrLowestTP[i].x)+','+inttostr(distArrLowestTP[i].y)+')');
          end;
        end;
      end;
    end;
  end;
  for z:=0 to high(ATPA) do // Debug output to get a nice chart :)
  begin
    writeln ('distArrLowest['+inttostr(z)+'] = '+inttostr(distArrLowest[z])+'  @  distArrLowestTP['+inttostr(z)+'] ('+inttostr(distArrLowestTP[z].x)+','+inttostr(distArrLowestTP[z].y)+')');
  end;
  TMin (tempdistArrLowest);
  for z:=0 to high(ATPA) do
  begin
    if tempdistArrLowest[0] = distArrLowest[z] then
    begin
      writeln ('Smallest distance is ['+inttostr(z)+'] = '+inttostr(distArrLowest[z])+' @  distArrLowestTP['+inttostr(z)+'] ('+inttostr(distArrLowestTP[z].x)+','+inttostr(distArrLowestTP[z].y)+')');
      result := distArrLowestTP[z];
    end;
  end;
end;

{******************************************************************************}
{ function SubPointDistancesTP (ATPA : T2DPointArray, TP : TPoint) : TPoint;   }
{ By: Cstrike                                                                  }
{ Description: Returns TPoint from ATPA which is closest to a TP you input     }
{******************************************************************************}
function SubPointDistancesTP (ATPA : T2DPointArray; TP : TPoint) : TPoint;
var distArrLowest, tempdistArrLowest, distTPAInt, tempdistTPATInt : TIntegerArray;
    distArrLowestTP : TPointArray;
    currentTile : TTile;
    i, j, k, z : Integer;
begin
  if not LoggedIn then exit;
  currentTile := PointToTile(TP); // Don't remove this, it's needed
  writeln ('SubPointDist: Current tile = ('+inttostr(currentTile.x)+','+inttostr(currentTile.y)+')');
  writeln ('high(ATPA) = ' + inttostr(high(ATPA)));
  SetArrayLength (distArrLowest, high(ATPA)+1); // The array that holds all the *smallest* distances from each TPA
  SetArrayLength (tempdistArrLowest, high(ATPA)+1);
  SetArrayLength (distArrLowestTP, high(ATPA)+1);
  for i:=0 to high(ATPA) do // For the entire ATPA do...
  begin
    writeln ('Debugging: high(ATPA)[i] = ' + inttostr(high(ATPA[i])));
    SetArrayLength (distTPAInt, high(ATPA[i])+1);
    SetArrayLength (tempdistTPATInt, high(ATPA[i])+1);
    for j:=0 to high(ATPA[i]) do // For each TPA in ATPA do...
    begin
      distTPAInt[j] := Distance (currentTile.x, currentTile.y, ATPA[i][j].x, ATPA[i][j].y);
      tempdistTPATInt[j] := Distance (currentTile.x, currentTile.y, ATPA[i][j].x, ATPA[i][j].y);
      writeln ('Debugging: ATPA['+inttostr(i)+']['+inttostr(j)+'] distance = '+inttostr(distTPAInt[j])+' ('+inttostr(ATPA[i][j].x)+','+inttostr(ATPA[i][j].y)+')'); // Debug
      if j = high(ATPA[i]) then // When we reach the top of our TPA, do the following [only because I cant do this outside the for loop...]
      begin
        TMin (tempdistTPATInt); // Return the integer thats the SMALLEST distance from the TIntegerArray
        writeln ('Debugging: Minimum distance (tempdistTPAInt[0])= '+inttostr(tempdistTPATInt[0]));
        distArrLowest[i] := tempdistTPATInt[0];
        tempdistArrLowest[i] := tempdistTPATInt[0];
        for k:=0 to high(ATPA[i]) do // This goes back and gives us the TPoint that matches up with the smallest distance, and stores it in an array for future decisions
        begin
          if distArrLowest[i] = distTPAInt[k] then
          begin
            distArrLowestTP[i] := ATPA[i][k];
            //writeln ('distArrLowestTP['+inttostr(i)+'] = ('+inttostr(distArrLowestTP[i].x)+','+inttostr(distArrLowestTP[i].y)+')');
          end;
        end;
      end;
    end;
  end;
  for z:=0 to high(ATPA) do // Debug output to get a nice chart :)
  begin
    writeln ('distArrLowest['+inttostr(z)+'] = '+inttostr(distArrLowest[z])+'  @  distArrLowestTP['+inttostr(z)+'] ('+inttostr(distArrLowestTP[z].x)+','+inttostr(distArrLowestTP[z].y)+')');
  end;
  TMin (tempdistArrLowest);
  for z:=0 to high(ATPA) do
  begin
    if tempdistArrLowest[0] = distArrLowest[z] then
    begin
      writeln ('Smallest distance is ['+inttostr(z)+'] = '+inttostr(distArrLowest[z])+' @  distArrLowestTP['+inttostr(z)+'] ('+inttostr(distArrLowestTP[z].x)+','+inttostr(distArrLowestTP[z].y)+')');
      result := distArrLowestTP[z];
    end;
  end;
end;

{******************************************************************************}
{ function AssignNodeLocation (maxTileRadius : integer) : String;              }
{ By: Cstrike                                                                  }
{ Description: Using reflection tiles, it will assess your current position    }
{ and based on how large of a tile radius you input, it will return the three  }
{ letter node you are at. If it doesn't work, it returns as an empty string    }
{******************************************************************************}
function AssignNodeLocation (maxTileRadius : integer) : String;
var i : Integer;
    currentTile : TTile;
    location : String;
begin
  if not LoggedIn then exit;
  currentTile := GetMyPos;
  location := ''; // This is for failsafes
  for i:=0 to high(NodeArray) do
  begin
    if (currentTile.x < (NodeArray[i].x+maxTileRadius)) and (currentTile.x > (NodeArray[i].x-maxTileRadius)) and (currentTile.y < (NodeArray[i].y+maxTileRadius)) and (currentTile.y > (NodeArray[i].y-maxTileRadius)) then // If were in a box defined by the given radius then...
    begin
      case i of
      0: location := 'VWB';
      1: location := 'FEB';
      2: location := 'LNE';
      3: location := 'DRB';
      4: location := 'BBC';
      end;
    end;
  end;
  if location = '' then // If we can't change the variable to any text then...
  begin
    location := 'none';
  end;
  writeln ('In node range = ('+location+')');
  result := location;
end;

{******************************************************************************}
{ procedure procedure TravelToNode (startNode, endNode : string);              }
{ By: Cstrike                                                                  }
{ Description: Travels between nodes. Must use node names. Current names are:  }
{ VWB = varrock west bank FEB = falador east bank BBC = barb village center    }
{ (south of dungeon entrance) DRB = draynor bank LNE = Lumbridge, northeast of }
{ the lumby castle. Use upper case for now                                     }
{******************************************************************************}
procedure TravelToNode (startNode, endNode : string);
var pathToWalk : TPointArray;
    pathToWalkTTA : TTileArray;
begin
  if not LoggedIn then exit;
  writeln ('Path requested ["'+startNode+ '" to "'+endNode+'"]');
  case startNode of
    // Varrock west bank
    'VWB':
    begin
      case endNode of
        'FEB': pathToWalk := CombineTPA(VWB_BBC, BBC_FEB);
        'LNE': pathToWalk := VWB_LNE;
        'DRB': pathToWalk := CombineTPA(VWB_LNE, LNE_DRB);
        'BBC': pathToWalk := VWB_BBC;
      end;
    end;
    // Falador East bank
    'FEB':
    begin
      case endNode of
      'VWB': pathToWalk := CombineTPA(FEB_BBC, BBC_VWB);
      'LNE': pathToWalk := CombineTPA(FEB_DRB, DRB_LNE);
      'DRB': pathToWalk := FEB_DRB;
      'BBC': pathToWalk := FEB_BBC;
      end;
    end;
    // Lumbridge north east
    'LNE':
    begin
      case endNode of
      'VWB': pathToWalk := LNE_VWB;
      'FEB': pathToWalk := CombineTPA(LNE_DRB, DRB_FEB);
      'DRB': pathToWalk := LNE_DRB;
      'BBC': pathToWalk := CombineTPA(LNE_VWB, VWB_BBC);
      end;
    end;
    // Draynor bank
    'DRB':
    begin
      case endNode of
      'VWB': pathToWalk := CombineTPA(DRB_LNE, LNE_VWB);
      'FEB': pathToWalk := DRB_FEB;
      'LNE': pathToWalk := DRB_LNE;
      'BBC': pathToWalk := CombineTPA(DRB_FEB, FEB_BBC);
      end;
    end;
    // Barbarian village center
    'BBC':
    begin
      case endNode of
      'VWB': pathToWalk := BBC_VWB;
      'FEB': pathToWalk := BBC_FEB;
      'LNE': pathToWalk := CombineTPA(BBC_VWB, VWB_LNE);
      'DRB': pathToWalk := CombineTPA(BBC_FEB, FEB_DRB);
      end;
    end;
  end; // End of all cases
  AddTPAToTTA  (pathToWalk, pathToWalkTTA);
  if WalkPath (pathToWalkTTA) then
  begin
    writeln ('Successfully walked');
  end else
  begin
    writeln ('Failure in walking');//["'+startNode+ '" to "'+endNode+'"]');
  end;
end;

{******************************************************************************}
{ function RetrieveToClosestHighwayPoint : TPoint;                             }
{ By: Cstrike                                                                  }
{ Description: Using the SubStreet ATPA, it will search for the closest TPoint }
{ and then it will walk that path until the last TPoint in the path. Returns   }
{ the last TPoint in the path. This SHOULD be a TPoint on a highway or later   }
{ parts of the script probably wont work unless you re-code it                 }
{ Ex: Takes you from your location through a substreet to SubStreet[i][0],     }
{ which is a highway point (or should be). The A next to TPAPosA/ATPAPosA      }
{ has no actual meaning, just a placeholder to be 'different'. Sorry.          }
{******************************************************************************}
// THIS IS THE MESSED UP PROCEDURE
// Should return us to the closest highway point.
function RetrieveToClosestHighwayPoint : TPoint;
var TPSubstreetClosest, TPHighwayClosest, currentPosTP : TPoint;
    TPA : TPointArray;
    ATPAposA, TPAPosA, highTPA: Integer;
    TTA, singleTTA : TTileArray;
    myCurrentPos, HighwayClosestTile : TTile;
begin
  if not LoggedIn then exit;
  TPHighwayClosest := SubPointDistances (Highway); // Search all highways and return closest highway point
  TPSubstreetClosest := SubPointDistances (SubStreet); // Searches ALL the substreets, and returns TP as the closest point
  myCurrentPos := GetMyPos;
  currentPosTP := TileToPoint (myCurrentPos);

  // If were closer to a highway than a path...
  if Distance (TPHighwayClosest.x, TPHighwayClosest.y, currentPosTP.x, currentPosTP.y) < Distance (TPSubstreetClosest.x, TPSubstreetClosest.y, currentPosTP.x, currentPosTP.y) then
  begin
    writeln ('Debugging: RetrieveToClosestHighwayPoint says were closer to highway than a substreet');
    DebugCurrentPos; // Debug
    HighwayClosestTile := PointToTile (TPHighwayClosest);
    if TileOnMM (HighwayClosestTile) then
    begin
      singleTTA := [HighwayClosestTile];
      if WalkPath (singleTTA) then writeln ('Debugging: Walked successfully to closest highway tile') else writeln ('WARNING: Could not walk to closest highway tile. Function soon to implode');
    end else
    begin
      FindPathToTile (HighwayClosestTile, 7); // Change this if it sucks
    end;
    result := TPHighwayClosest; // Needs more failsafes
  end else // Else if were closer to a substreet path than the highway...
  begin
    writeln ('Debugging: RetrieveToClosestHighwayPoint says were closer to a substreet rather than a highway');
    //WARNING: Added TPSubstreetClosest to the next procedure, haven't tested it
    FindTPInATPA (TPSubstreetClosest, SubStreet, ATPAposA, TPAPosA); // Searches all the substreets to find which TPA in the ATPA contains our point [aka: finds a TPoint in an ATPA], if multiple return for whatever reason, it will take the last one it finds I guess. Note, the last two variables are position remembering (aka: remembers the slot in the ATPA and TPA)
    AddTPAFromDownToTTA (SubStreet, ATPAPosA, TPAPosA, TPA); // Now that it knows the ATPA/TPA/TP, it will take the TPoint it found, using its location and go along the TPA backwards from TPA[i] to TPA[0], which is technically our retrieved path. Remember, all our paths were designed from the highway and branch out, so it makes sense to find our spot and work backwards to a highway
    AddTPAToTTA (TPA, TTA); // With this TPA we made above, convert it to a TTileArray for reflection
    WalkPath (TTA); // Walk us to the point in the Highway[?]
    DebugCurrentPos; // Debug
    FFlag(0);
    writeln ('Now trying to get to nearest node');  wait (3000); // Debug
    highTPA := high(TPA);
    writeln ('TPA[0] = ('+inttostr(TPA[highTPA].x)+','+inttostr(TPA[highTPA].y)+')'); // Debug
    result := SubStreet[ATPAPosA][0]; // Returns the TPoint that
  end;
end;

{******************************************************************************}
{ function RetrieveToClosestNode : String;                                     }
{ By: Cstrike                                                                  }
{ Description: Returns a string of the node you went to. It will return three  }
{ lettered node in capitals.                                                   }
{ Ex: This procedure walks the closest street to a highway, then walks the     }
{ highway to a node, then returns the node name for use in other functions     }
{******************************************************************************}
function RetrieveToClosestNode : String;
var TP : TPoint;
    TPA : TPointArray;
    ATPAPosH, TPAPosH, highTPA : Integer;
    TTA : TTileArray;
begin
  if not LoggedIn then exit;
  // DEBUG OCT 10th 2010, This is where it's messing up... below:
  TP := RetrieveToClosestHighwayPoint; // This will first walk us on a street towards a highwaypoint, and then return the highway point that it reached
  writeln ('Debugging: RetrieveToClosestHighwayPoint, says this: Point('+inttostr(TP.x)+','+inttostr(TP.y)+') in an ATPA');
  FindTPInATPA (TP, Highway, ATPAPosH, TPAPosH); // Find our location in terms of ATPA[ATPAPosH][TPAPosH]
  highTPA := high(Highway[ATPAPosH]); // This gives us how big our array is, so we can later determine which node we are closer to (since it has to decide between which 2 to walk to... and the closer looks less obvious right? Imagine being next to draynor and walking all the way to lumby)
  writeln ('highTPA = '+inttostr(highTPA)); // Debug
  if TPAPosH >= (highTPA/2) then // If we are in the upper half of the TPA [or middle] then
  begin
    writeln ('Greater than half, do the UpFragment');
    CreateTPAUpFromFragment (Highway, ATPAPosH, TPAPosH, TPA);
  end else // Else if we are in the lower half of the TPA then
  begin
    writeln ('Less than half, do the DownFragment');
    CreateTPADownFromFragment (Highway, ATPAPosH, TPAPosH, TPA);
  end;
  DebugTheTPA (TPA);
  AddTPAToTTA (TPA, TTA);
  WalkPath (TTA);
  result := AssignNodeLocation (8);
  writeln ('Result: '+result);
end;

{******************************************************************************}
{ function DetermineNodeName (TP : TPoint) : String                            }
{ By: Cstrike                                                                  }
{ Description: Checks node TP's with inputted TP and returns node name. If no  }
{              node is found, returns ''.                                      }
{******************************************************************************}
function DetermineNodeName (TP : TPoint) : String;
begin
  if not LoggedIn then exit;
  writeln ('DetermineNodeNameFunction: Point("'+inttostr(TP.x)+ '" to "'+inttostr(TP.y)+'")');
  result := '';
  case TP of
    Point((VARROCKWESTBANK_X + X_OFFSET),(VARROCKWESTBANK_Y + Y_OFFSET)):
    begin
      result := 'VWB';
      writeln ('Debugging: Node name determined = '+result);
    end;
    Point((FALADOREASTBANK_X + X_OFFSET),(FALADOREASTBANK_Y + Y_OFFSET)):
    begin
      result := 'FEB';
      writeln ('Debugging: Node name determined = '+result);
    end;
    Point((LUMBRIDGENE_X + X_OFFSET),(LUMBRIDGENE_Y + Y_OFFSET)):
    begin
      result := 'LNE';
      writeln ('Debugging: Node name determined = '+result);
    end;
    Point((DRAYNORBANK_X + X_OFFSET),(DRAYNORBANK_Y + Y_OFFSET)):
    begin
      result := 'DRB';
      writeln ('Debugging: Node name determined = '+result);
    end;
    Point((BARBVILLAGEC_X + X_OFFSET),(BARBVILLAGEC_Y + Y_OFFSET)):
    begin
      result := 'BBC';
      writeln ('Debugging: Node name determined = '+result);
    end;
  end;
end;

{******************************************************************************}
{ procedure GoToNodeFromAnywhere (Location : string);                          }
{ By: Cstrike                                                                  }
{ Description: Takes you from anywhere, to the location you want. Location you }
{ input should be 3 capital letters like VWB. Should only use defined nodes,   }
{ don't try entering something like VEB unless in the future it is defined as  }
{ a node to actually go to. Use FEB/VWB/BBC/LNE/DRB for now                    }
{******************************************************************************}
procedure GoToNodeFromAnywhere (Location : string);
var startNode : String;
begin
  if not LoggedIn then exit;
  startNode := RetrieveToClosestNode;
  if (startNode = Location) then writeln ('Already at '+Location) // This prevents TravelToNode from attempting to walk with 0 TTiles (which crashes the script)
  else TravelToNode (startNode, Location);
end;

// If distance < 10 in WalkTo from highway or it's closest to a highway...
// TP is the point you overall want to end up at, at the end of this entire script
// ClosestHighwayTP is the TPoint on the highway that is where you're going to stop, and then start [blindwalking if need be] towards your point
procedure RetrieveWalkCloseToHighway (TP, ClosestHighwayTP : TPoint);
var
    ATPAPos, TPAPos, highTPA: Integer;
    TPA: TPointArray;
    TTA : TTileArray;
    TileToWalkTo: TTile;
    nodeName : String;
begin
  writeln ('Debugging: RetreiveWalkCloseToHighway');
  writeln ('Debugging: TP = Point('+inttostr(TP.x)+','+inttostr(TP.y)+') in an ATPA');
  writeln ('Debugging: ClosestHighwayTP = Point('+inttostr(ClosestHighwayTP.x)+','+inttostr(ClosestHighwayTP.y)+') in an ATPA');
  FindTPInATPA (ClosestHighwayTP, Highway, ATPAPos, TPAPos); // Find where our closest highway TP (relative to our requested spot) is in the ATPA 'highway'
  highTPA := high(Highway[ATPAPos]); // This gives us how big our array is, so we can later determine which node we are closer to (since it has to decide between which 2 to walk to... and the closer looks less obvious right? Imagine being next to draynor and walking all the way to lumby)
  writeln ('highTPA = '+inttostr(highTPA)); // Debug
  if TPAPos >= (highTPA/2) then // If we are in the upper half of the TPA [or middle] then
  begin
    writeln ('Greater than half, do the UpFragment and invert');
    CreateTPAUpFromFragmentInvert (Highway, ATPAPos, TPAPos, TPA);
  end else // Else if we are in the lower half of the TPA then
  begin
    writeln ('Less than half, do the DownFragment and invert');
    CreateTPADownFromFragmentInvert (Highway, ATPAPos, TPAPos, TPA);
  end;
  DebugTheTPA (TPA); // Debug output
  nodeName := DetermineNodeName (TPA[0]); // Our node SHOULD be at TPA[0], so find what node we should end up at
  AddTPAToTTA (TPA, TTA);
  DebugTheTTA (TTA); // Debug
  // WALK TIME!! So far up to here is good debug
  //DEBUG/////////////////////////////////////////
  GoToNodeFromAnywhere (nodeName); // First, go to closest node
  WalkPath (TTA); // Now that were at the node, walk the path
  wait (random(500)); // Now wait for safe measure ;)
  TileToWalkTo := PointToTile (TP); // WalkToTile (TP) here
  if TileOnMM (TileToWalkTo) then
  begin
    writeln ('Desired tile on minimap, attempting to walk to it');
    WalkToTile (TileToWalkTo, 1, 0);
  end else
  begin
    writeln ('Desired tile NOT on minimap, attempting to blindwalk to it');
    FindPathToTile (TP, 9); // Change walk radius of 9 if you think its too much
  end;
  {
  CurrentTile := GetMyPos;
  result := true;
  if ((currentTile.x - TP.x) < 4) or ((currentTile.x - TP.x) > -4) or ((currentTile.y - TP.y) < 4) or ((currentTile.y - TP.y) > -4) then
  begin
    writeln ('We are greater than 4 tiles away from desired point('+inttostr(TP.x)+','+inttostr(TP.y)+')');
    result := false;
  end else writeln ('At tile!!');
  }
end;


// If highway >= 10 away from WalkTo and Substreet is a shorter distance than Highway
procedure RetrieveWalkCloseToSubstreet (TP, ClosestHighwayTP : TPoint);
var closestTP, rootSubstreetTP : TPoint;
    ATPAPosS, TPAPosS, ATPAPosH, TPAPosH, highTPA, highTPAHighway : Integer;
    FullWalkingPath, SubStreetDesiredPath: TPointArray;
    TileToWalkTo: TTile;
    startFromIndexZero : Boolean; // If this is true in the script, it will use substreets to get to required TP, false means it will use a highway and then attempt to walk to it
    nodeName : String;
begin
  if not LoggedIn then exit;
  writeln ('**Beginning RetrieveWalkCloseToSubstreet');
  closestTP := SubPointDistancesTP(SubStreet, TP); //Find closest point in ATPA.TPA
  FindTPInATPA (closestTP, SubStreet, ATPAPosS, TPAPosS); //Determine what index it is, the S next to ATPAPos means 'S'ubstreet (since H is for 'H'ighway)
  writeln ('WalkTo(Substreet) ATPAPos = '+inttostr(ATPAPosS)); writeln ('WalkTo(Substreet) TPAPos = '+inttostr(TPAPosS)); // DEBUG
  rootSubstreetTP := SubStreet[ATPAPosS][0]; //Find what highway it connects to, since the SubStreet[ATPAPos][0] HAS to be a TPoint on the Highway ATPA
  FindTPInATPA (rootSubstreetTP, Highway, ATPAPosH, TPAPosH); // Finds what highway index were looking for, and what point to walk from [The H next to ATPAPos/TPAPos is used for 'H'ighway, because ATPAPos is for the substreet)
  highTPAHighway := high(Highway[ATPAPosH]); // This gives us how big our array is, so we can later determine which node we are closer to (since it has to decide between which 2 to walk to... and the closer looks less obvious right? Imagine being next to draynor and walking all the way to lumby)
  writeln ('highTPASubstreet = '+inttostr(highTPA)); writeln ('highTPAHighway = '+inttostr(highTPAHighway)); // Debug
  startFromIndexZero := false; // This is used when generating our big walk, whether to start from the top or bottom of the highway array, if true... starts from Highway[i][0]
  writeln ('**Beginning HighwayNodeName determination');
  if TPAPosH >= (highTPAHighway/2) then // Search if we branch off in the upper half of the highway, or the lower half of the highway
  begin
    writeln ('Greater than half, search highest TPA point for node');
    writeln ('Using Highway['+inttostr(ATPAPosH)+']['+inttostr(highTPAHighway)+']');
    nodeName := DetermineNodeName (Highway[ATPAPosH][highTPAHighway]); // Search the top of the Highway[Index] array, since the top of the array will be a node position, and we are in the upper half of the array lets just go to the closest one ;)
    writeln ('Node name determined that is closest: '+nodeName);
  end else // Else if we are in the lower half of the TPA then
  begin
    writeln ('Less than half, search TPA[0] for node');
    writeln ('Using Highway['+inttostr(ATPAPosH)+'][0]');
    nodeName := DetermineNodeName (Highway[ATPAPosH][0]);
    writeln ('Node name determined that is closest: '+nodeName); // Same as the code slightly above ^^^ except were in lower half so check the bottom of the array
    startFromIndexZero := true;
  end;
  writeln ('**Beginning FullWalkingPath creation: Create highway path');
  if startFromIndexZero then // If we started getting the highway from Highway[ATPAPosH][0] then do this stuff
  begin
    writeln ('StartFromIndexZero = true');
    CreateTPADownFromFragmentInvert (Highway, ATPAPosH, TPAPosH, FullWalkingPath); // Creates from position zero up to our desired HighwayPoint and stores it in FullWalkingPath
  end else // Start from Highway[0][HighestIndex]
  begin
    writeln ('StartFromIndexZero = false');
    CreateTPAUpFromFragmentInvert (Highway, ATPAPosH, TPAPosH, FullWalkingPath);
  end; // We've done the highway, now below, create the subpath
  writeln ('** Lets debug our FullWalkingPath TPA');
  DebugTheTPA (FullWalkingPath);
  //nodeName := DetermineNodeName (FullWalkingPath[0]); // Since our full walking path HAS to start at a node, logically if there were no errors... the very first point should be a node. This will tell us the node we have to be at! :)
  writeln ('** Node name: '+nodeName+' -- determined from Point('+inttostr(FullWalkingPath[0].x)+','+inttostr(FullWalkingPath[0].y)+')');
  writeln ('A_PosS = '+inttostr(ATPAPosS));
  writeln ('T_PosS = '+inttostr(TPAPosS));
  CreateTPADownFromFragmentInvert (SubStreet, ATPAPosS, TPAPosS, SubStreetDesiredPath); // Create a path from SubStreet[ATPAPos][0] [which we remove later since Highway[ATPAPosH][TPAPosH] = SubStreet[ATPAPos][0]
  //RemoveTPFromTPA (SubStreetDesiredPathTemp, SubStreetDesiredPath, 0); // Remove position [0] since that is the root spot that connects to the highway. Since our highway code walks to the root point of the SubStreet, it would just click it twice, and we don't want that.
  writeln ('** Debug substreetdesiredpath TPA');
  DebugTheTPA (SubStreetDesiredPath);
  FullWalkingPath := CombineTPA (FullWalkingPath, SubStreetDesiredPath);
  writeln ('**TPAs combined, lets debug:');
  DebugTheTPA (FullWalkingPath);
  //Determine node we should be at before walking the above path
  GoToNodeFromAnywhere (nodeName); // This is what it SHOULD do if there is no error. Will crash if string is '', must but FAIL-SAFE in here later FAILSAFE
  writeln ('** GONE to starting node');
  wait (random(500));
  WalkPath (FullWalkingPath); //walk generated path
  wait (random(500)); // Prevent random stupid errors I guess, maybe should use FFlag(0); or something
  TileToWalkTo := PointToTile (TP); // Turn our point into a tile
  if TileOnMM (TileToWalkTo) then WalkToTile (TileToWalkTo, 1, 0) // If tile's on the minimap, walk to it NEEDS FAILSAFE
  else FindPathToTile (TP, 6); // Else, blindwalk because it's far
end;

{******************************************************************************}
{ procedure function WalkTo (TP : TPoint) : Boolean;                           }
{ By: Cstrike                                                                  }
{ Description: Will take you from your location to Tile(TP.x,TP.y). Probably   }
{ will not work if you're somewhere far away with no node path [ex: wildy].    }
{ Returns true if you reach TP.                                                }
{******************************************************************************}
function WalkTo (TP : TPoint) : Boolean;
var highwayTP, substreetTP: TPoint;
begin
  Result := False;
  if not LoggedIn then exit;
  highwayTP := SubPointDistancesTP (Highway, TP); //Debug result: Works fine ;)
  if Distance (TP.x, TP.y, highwayTP.x, highwayTP.y) < 10 then //Debug result: Works fine ;)
  begin
    writeln ('Debugging: Using RetrieveWalkCloseToHighway');
    RetrieveWalkCloseToHighway (TP, highwayTP);
  end else // Else if distance greater than 10
  begin
    substreetTP := SubPointDistancesTP (SubStreet, TP);
    if Distance (TP.x, TP.y, highwayTP.x, highwayTP.y) < Distance (TP.x, TP.y, substreetTP.x, substreetTP.y) then
    begin
      writeln ('Highway >= 10, and highway closer');
      RetrieveWalkCloseToHighway (TP, highwayTP);
    end else
    begin
      writeln ('Highway >= 10, and substreet closer');
      RetrieveWalkCloseToSubstreet (TP, substreetTP);
    end;
  end;
  DebugCurrentPos;
end;

{$ENDIF}
{$ENDIF}

function WorldWalk(ToLoc: TPoint): boolean;
begin
	{$IFDEF Extra_WorldWalker_cstrike}
  {$IFDEF REFLECTION}
		Result := WalkTo(ToLoc);
		//Track_Result(T_WorldWalker, Result);
  {$ENDIF}
	{$ENDIF}
end;
