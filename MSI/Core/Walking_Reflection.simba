(*
Walking_Reflection
==================

The Reflection Walking file includes functions & procedures that have anything
to do with reflection walking. You'll notice the defines ({$IFDEF REFLECTION})
used throughout these methods; these are used so MSI will still compile if the
user decides to exclude reflection or if reflection is broken.

*)

(*
MSI_WaitTile
~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_WaitTile(Tile: TPoint): Boolean;

Simple, yet effective function used as a substitute for Flag functions.
MSI_WaitTile returns true with 'Tile' is on the minimap. See MSI_WalkTile to
see exactly how it's used.

.. note::

  | Author: Coh3n
  | Last Updated: 26 January 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_ClickTile(i)) then
    MSI_WaitTile(i + 1); // Waits for the next tile in the path
*)
function MSI_WaitTile(Tile: TPoint): Boolean;
{$IFDEF REFLECTION}
var
  t: Integer;
{$ENDIF}
begin
  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  t := GetSystemTime + 15000; // Maximum wait time is 15 seconds
  repeat
    if (LeaveDangerZone) then
      MSI_Debug('Left danger zone');

    Result := TileOnMM(Tile);

    MSI_FindRandoms(False);
    MSI_AntiBan(RandomRange(200, 800), ANTI_BAN_CHANCE);
  until(Result or (GetSystemTime > t));
  {$ENDIF}
end;

(*
MSI_ClickTile
~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_ClickTile(Tile: TPoint): Boolean;

Checks to see if the player is near 'Tile', if so, returns true, otherwise it
will verify the tile is on the minimap and return true when clicked.

.. note::

  | Author: marpis
  | Last Updated: 26 January 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_ClickTile(Point(1234, 4321))) then
    MSI_Debug('Clicked tile');
*)
function MSI_ClickTile(Tile: TPoint): Boolean;
{$IFDEF REFLECTION}
var
  MP: TPoint;
{$ENDIF}
begin
  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  MP := TileToMM(Tile);

  if (Distance(MP.X, MP.Y, MMCX, MMCY) <= 5) then
  begin
    MSI_Debug('Already near tile');
    Result := True;
    Exit;
  end;

  if (TileOnMM(Tile)) then
  begin
    MSI_Debug('Tile('+IntToStr(Tile.x)+', '+IntToStr(Tile.y)+') is on the minimap');
    Mouse(MP.X, MP.Y, 5, 5, True);
    Result := True;
  end else
    MSI_Debug('Tile('+IntToStr(Tile.x)+', '+IntToStr(Tile.y)+') is not on the minimap');
  {$ENDIF}
end;

(*
MSI_AtLocation
~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_AtLocation(Loc: Integer): Boolean;

Returns true if the player is at the location 'Loc'.

.. note::

  | Author: Coh3n
  | Last Updated: 01 November 2010 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_AtLocation(LOC_VE_BANK)) then
    MSI_Debug('We are at Varrock East Bank');
*)
function MSI_Relocate(Loc: Integer): Boolean; forward;
function MSI_AtLocation(Loc: Integer): Boolean;
{$IFDEF REFLECTION}
var
  i, d: Integer;
  t: TPoint;
{$ENDIF}
begin
  if (not LoggedIn) then
    Exit;

  if (Loc = LOC_POWER_SKILL) then
  begin
    MSI_SubDebug('We are powerskilling, we have no specific location');
    Result := True;
  end;

  {$IFDEF REFLECTION}
  with MSI_Locations[Loc] do
  begin
    for i := 0 to High(RelocatePoints) do
      if (TileOnMM(RelocatePoints[i])) then
      begin
        t := TileToMM(RelocatePoints[i]);
        d := Distance(t.x, t.y, MMCX, MMCY);
        MSI_SubDebug('Distance from player to location: ' + IntToStr(d));

        if (d <= 30) then
        begin
          Result := True;
          Break;
        end else
          Result := MSI_Relocate(Loc);
      end;

    if (Result) then
    begin
      MSI_SubDebug('Player is at ' + Name);
      MSI_Players[CurrentPlayer].Location := Loc;
    end;
  end;
  {$ENDIF}
end;

(*
MSI_LoadTilePath
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_LoadTilePath(sLoc, eLoc: Integer): T2DPointArray;

Returns the tile path from the starting location (sLoc) to the ending location
(eLoc). Paths are read depending on the users current script.

.. note::

  | Author: Coh3n
  | Last Updated: 30 November 2010 by Coh3n

Example:

.. code-block:: pascal

  // Loads the path from VE bank to trees, assuming the player is using SCRIPT_VE_TREES
  MSI_LoadTilePath(LOC_VE_BANK, LOC_VE_TREES);
*)
function MSI_LoadTilePath(sLoc, eLoc: Integer): T2DPointArray;
var
  Script: TScript;
begin
  if (not LoggedIn) then
    Exit;

  Script := MSI_Scripts[MSI_Players[CurrentPlayer].Scripts[CurrentScript].Name];

  if (sLoc = Script.PathInfo.StartLoc) then
    Result := Script.PathInfo.Reflection
  else
    if (sLoc = Script.PathInfo.EndLoc) then
      Result := MSI_MirrorATPA(Script.PathInfo.Reflection);

  MSI_SubDebug('Loaded tile path: '+ToStr(Result));
end;

(*
MSI_WalkTilePath
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_WalkTilePath(tPath: TPointArray): Boolean;

Walks the entire tile path (tPath). Uses MSI_WaitTile for every tile except the
last one (uses MSI_Flag(0) instead) to ensure the player has stopped moving
before searching for objects on the mainscreen.

.. note::

  | Author: marpis & Coh3n
  | Last Updated: 26 January 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_WalkTilePath(TilePathHere)) then
    MSI_Debug('Walked path');
*)
function MSI_WalkTilePath(tPath: TPointArray): Boolean;
{$IFDEF REFLECTION}
var
  h, i, t: Integer;
  mPos: TPoint;
  stopMoving: Boolean;
{$ENDIF}
begin
  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  with MSI_Players[CurrentPlayer] do
  begin
    t := GetSystemTime + (Length(tPath) * 60 + 180) * 1000; // A minute for each tile + 3 minutes
    h := High(tPath);

    repeat
      for i := h downto 0 do
      begin
        stopMoving := (i = h);

        if (not MSI_ClickTile(tPath[i])) then
        begin
          if (i = 0) then
            Exit;

          Continue;
        end else
          if (stopMoving) then
            MSI_Flag(0)
          else
            MSI_WaitTile(tPath[i + 1]);

        mPos := GetMyPos;
        Result := (Distance(mPos.x, mPos.y, tPath[h].x, tPath[h].y) <= 10);
        Break;
      end;
    until(Result or (GetSystemTime > t));
  end;
  {$ENDIF}
end;

(*
MSI_ReflectionWalk
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_ReflectionWalk(sLoc, eLoc: Integer): Boolean;

Walks the entire path from start (sLoc) to finish (eLoc), including obstacles.
Returns true if the player is at the ending location.

.. note::

  | Author: marpis & Coh3n
  | Last Updated: 26 January 2011 by Coh3n

Example:

.. code-block:: pascal

  // Walks to VE mine only if your player is set to use SCRIPT_VE_MINER
  MSI_ReflectionWalk(LOC_VE_BANK, LOC_VE_MINE);
*)
function MSI_ReflectionWalk(sLoc, eLoc: Integer): Boolean;
{$IFDEF REFLECTION}
var
  tPath: T2DPointArray;
  i, t, h, obsLen, pathLen: Integer;
  script: TScript;
  obsSolved: TBooleanArray;
{$ENDIF}
begin
  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  script := MSI_Scripts[MSI_Players[CurrentPlayer].Scripts[CurrentScript].Name];
  SetLength(obsSolved, Length(Script.PathInfo.Obstacles));

  MSI_AddHeader('MSI_ReflectionWalk');

  tPath := MSI_LoadTilePath(sLoc, eLoc);
  t := GetSystemTime + (Length(tPath) * 60 + 180) * 1000; // A minute for each tile + 3 minutes
  obsLen := High(Script.PathInfo.Obstacles);
  pathLen := High(tPath);

	repeat
		for i := 0 to pathLen do
      with MSI_Players[CurrentPlayer] do
		  begin
        // Walk the leg of the path
				if (not (MSI_WalkTilePath(tPath[i]))) then
				begin
          MSI_Debug('Failed to walk leg '+IntToStr(i)+' of script: '+Capitalize(Script.Name));
				  ReportInfo.FalseReason := 'Failed to walk to ' + MSI_Locations[eLoc].Name;
          MSI_CloseHeader('MSI_ReflectionWalk: ' + BoolToStr(Result));
				  Location := LOC_LOST;
          Exit;
				end;

        // Handle the obstacle
		    if (MSI_HandleObstacle(script, sLoc, h)) then
        begin
          obsSolved[h] := True;
		      if (h <> obsLen) then
		        Inc(h);
        end;

        // Return true if the player is at the ending location
		    if (MSI_AtLocation(eLoc)) then
		    begin
		      Result := True;
		      Break;
		    end;
		  end;
	until(Result or (GetSystemTime > t));

	MSI_CloseHeader('MSI_ReflectionWalk: ' + BoolToStr(Result));
  {$ENDIF}
end;

(*
MSI_HybridWalk
~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_HybridWalk(StartLoc, EndLoc: Integer): Boolean;

Walks the entire path from start (sLoc) to finish (eLoc), including obstacles,
using MSI's hybrid system. It uses color walking and checks with reflection. If
the color part fails, a new point will be automatically generated (see
Walking_Color.simba). If a color path for the script being used doesn't exist,
a new path with be generated. Returns true if the player is at the ending
location.

.. note::

  | Author: Coh3n
  | Last Updated: 11 February 2011 by Coh3n

Example:

.. code-block:: pascal

  MSI_HybridWalk(LOC_VE_BANK, LOC_VE_MINE);
*)
function MSI_HybridWalk(StartLoc, EndLoc: Integer): Boolean;
{$IFDEF REFLECTION}
var
  h, hi, i, j: Integer;
  cPath: T2DIntegerArray;
  rPath, dupPath: T2DPointArray;
  obsSolved: TBooleanArray;
  cPoint, rPoint: TPoint;
  pointDistance, obsHi: Integer;
  script: TScript;
  pName: string;
{$ENDIF}
begin
  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  MSI_AddHeader('MSI_HybridWalk: '+IntToStr(StartLoc)+' to '+IntToStr(EndLoc));

  // Declare the color and reflection paths
  cPath := MSI_FillColorPath(MSI_LoadColorPath(StartLoc, EndLoc));
  rPath := MSI_LoadTilePath(StartLoc, EndLoc);
  script := MSI_Scripts[MSI_Players[CurrentPlayer].Scripts[CurrentScript].Name];
  SetLength(obsSolved, Length(Script.PathInfo.Obstacles));
  obsHi := High(Script.PathInfo.Obstacles);
  hi := High(rPath);

  // Check the length of the paths
  if (Length(cPath) <> Length(rPath)) then
  begin
    MSI_Debug('Path lengths do not match');
    MSI_Debug('Generating new color path');
    pName := Capitalize(MSI_Locations[StartLoc].Name) + ' to ' + Capitalize(MSI_Locations[EndLoc].Name);

    // Generate and set the script's color paths
    with MSI_Players[CurrentPlayer].Scripts[CurrentScript] do
      if (StartLoc = MSI_Scripts[Name].PathInfo.StartLoc) then
        MSI_Scripts[Name].PathInfo.ColorTo := MSI_AddWalkPoints(rPath, pName)
      else
        if (StartLoc = MSI_Scripts[Name].PathInfo.EndLoc) then
          MSI_Scripts[Name].PathInfo.ColorFrom := MSI_AddWalkPoints(rPath, pName);

    Wait(RandomRange(500, 1000));
    Result := MSI_AtLocation(EndLoc);

    MSI_CloseHeader('MSI_HybridWalk: '+BoolToStr(Result));
    Exit;
  end;

  // Duplicate the path so the global paths aren't reset
  dupPath := CopyATPA(rPath);

  for i := 0 to hi do
  begin
    MSI_DeletePointInTPA(dupPath[i], 0);
    MSI_Debug('Temp Path: ' + ToStr(dupPath[i]));

    // Check the length of the legs of the paths
    if (Length(cPath[i]) <> Length(dupPath[i])) then
    begin
      MSI_Debug('Path leg lengths do not match');
      MSI_CloseHeader('MSI_HybridWalk: '+BoolToStr(Result));
      Exit;
    end;

    for j := 0 to High(dupPath[i]) do
    begin
      // Get the minimap coord for the reflection and color points
      cPoint := MSI_GetWalkCoords(MSI_WalkPoints[cPath[i][j]]);
      rPoint := TileToMM(dupPath[i][j]);

      MSI_Debug('Color Point: '+IntToStr(cPoint.x)+', '+IntToStr(cPoint.y));
      MSI_Debug('Reflection Point: '+IntToStr(rPoint.x)+', '+IntToStr(rPoint.y));

      pointDistance := Distance(cPoint.x, cPoint.y, rPoint.x, rPoint.y);
      MSI_Debug('Distance between points: '+IntToStr(pointDistance));

      if (pointDistance > MAX_POINT_DIST) then
      begin
        // Create and set the new color point
        MSI_WalkPoints[cPath[i][j]] := MSI_GenerateWalkPoint(dupPath[i][j]);

        // Walk to the tile
        if (not MSI_ClickTile(dupPath[i][j])) then
				begin
          MSI_Debug('Failed to walk leg '+IntToStr(i)+' of script: '+Capitalize(Script.Name));
				  MSI_Players[CurrentPlayer].ReportInfo.FalseReason := 'Failed to walk to ' + MSI_Locations[EndLoc].Name;
          MSI_Players[CurrentPlayer].Location := LOC_LOST;
          MSI_CloseHeader('MSI_HybridWalk: '+BoolToStr(Result));
          Exit;
				end else
          if (j = High(dupPath[i])) then
            MSI_Flag(0)
          else
            MSI_WaitTile(dupPath[i][j + 1]);
      end else
        MSI_WalkToPoint(cPoint, cPath[i][j]);

      MSI_SaveWalkPoint(cPath[i][j]);
    end;

    // Handle the obstacle if there is one
    if (MSI_HandleObstacle(script, StartLoc, h)) then
    begin
      obsSolved[h] := True;
		  if (h <> obsHi) then
		    Inc(h);
    end;

    Result := MSI_AtLocation(EndLoc);
  end;

  MSI_CloseHeader('MSI_HybridWalk: '+BoolToStr(Result));
  {$ENDIF}
end;

(*
MSI_PerformWalk
~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_PerformWalk(startLoc, endLoc: Integer): Boolean;

This is the function that is called in MSI_Walk (Mainloop.simba). It takes into
consideration both color and reflection paths depending on the user's preference
as well as the current state of reflection.

.. note::

  | Author: Coh3n
  | Last Updated: 04 August 2010 by Coh3n

Example:

.. code-block:: pascal

  // Walks to VE mine only if your player is set to use SCRIPT_VE_MINER
  MSI_PerformWalk(LOC_VE_BANK, LOC_VE_MINE);
*)
function MSI_PerformWalk(startLoc, endLoc: Integer): Boolean;
var
  Script: TScript;
begin
  if (not LoggedIn) then
    Exit;

  Script := MSI_Scripts[MSI_Players[CurrentPlayer].Scripts[CurrentScript].Name];

  MakeCompass('n');
  RunEnergy(20);
  MSI_FindRandoms(True);

  // If reflection is broken, then use color walking
  if (ReflectionBroken) then
  begin
    Result := MSI_ColorWalk(startLoc, endLoc);
    Exit;
  end;

  case Lowercase(MSI_SetupVars[SETUP_WALKING]) of
    'reflection': Result := MSI_ReflectionWalk(startLoc, endLoc);
         'color': Result := MSI_ColorWalk(startLoc, endLoc);
        'hybrid': Result := MSI_HybridWalk(startLoc, endLoc);

    else
      Result := MSI_HybridWalk(startLoc, endLoc);
  end;
end;

