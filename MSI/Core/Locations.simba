(*
Locations
=========

The Locations file stores all the TLocation records used in MSI.

The source for Locations.simba can be found
`here <https://github.com/SRL/MSI/raw/master/MSI/Core/Locations.simba>`_.

*)

(*
MSI_LoadLocation
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_LoadLocation(Which: Integer): Boolean;

Loads the location 'Which' (sets 'Which' in the MSI_Locations global array).
This procedure should only be called in MSI_LoadAllLocations. 'Which' represents
the location constants MSI uses, which can be found in Globals.simba.

.. note::

  | Author: Coh3n
  | Last Updated: 10 October 2011 by Coh3n

Example:

.. code-block:: pascal

  for i := 0 to High(MSI_Locations) do
    MSI_LoadLocation(i);
*)
function MSI_LoadLocation(loc: integer): boolean;
var
  i: integer;
begin
   case loc of
     LOC_POWER_SKILL:
       with MSI_Locations[loc] do
       begin
         name := 'Powerskilling';
         atBank := false;
       end;

     LOC_LOST:
       with MSI_Locations[loc] do
       begin
         name := 'Lost';
         atBank := false;
       end;

     LOC_VE_OAKS:
       with MSI_Locations[loc] do
       begin
         name := 'Varrock East Oaks';
         atBank := false;

         setLength(subLocs, 3);
         with subLocs[0] do
         begin
           name := 'Varrock East Oak North';
           tileBox := intToBox(3279, 3422, 3284, 3428);
           compass := randomRange(75, 360);
         end;

         with subLocs[1] do
         begin
           name := 'Varrock East Oak Central';
           tileBox := intToBox(3280, 3415, 3286, 3420);
           compass := randomRange(260, 315);
         end;

         with subLocs[2] do
         begin
           name := 'Varrock East Oak South';
           tileBox := intToBox(3276, 3411, 3281, 3416);
           compass := randomRange(165, 195);
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].camera := false;
           subLocs[i].objects := MSI_Scripts[SCRIPT_VE_OAKS].Defaults.Trees;
         end;
       end;

     LOC_VE_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Varrock East Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Varrock East Bank';
           tileBox := intToBox(3251, 3418, 3256, 3423);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_VE_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_VE_BANK;

           reflection := [
             TPointArray([point(3222, 3217), point(3260, 3227),
                          point(3238, 3279), point(3240, 3308),
                          point(3298, 3358), point(3284, 3428),
                          point(3254, 3420)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '11_8', '11_7'])
           ];
         end;
       end;

     LOC_VE_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Varrock East Mine';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Varrock East Mine';
           tileBox := intToBox(3279, 3360, 3292, 3372);
           objects := MSI_Scripts[SCRIPT_VE_MINER].Defaults.Rocks;
         end;
       end;

     LOC_VE_FOUNTAIN:
       with MSI_Locations[loc] do
       begin
         name := 'Varrock East Fountain';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Varrock East Fountain';
           tileBox := intToBox(3235, 3431, 3242, 3438);
           objects := [FOUNTAIN_VE];
         end;
       end;

     LOC_GE_FOUNTAIN:
       with MSI_Locations[loc] do
       begin
         name := 'Grand Exchange Fountain';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Grand Exchange Fountain';
           tileBox := intToBox(3161, 3488, 3168, 3495);
           objects := [FOUNTAIN_GE];
         end;
       end;

     LOC_VW_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Varrock West Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Varrock West Bank';
           tileBox := intToBox(3182, 3433, 3190, 3445);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_VW_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_VW_BANK;

           reflection := [
             TPointArray([point(3222, 3217), point(3260, 3227),
                          point(3239, 3280), point(3241, 3329),
                          point(3212, 3378), point(3212, 3426),
                          point(3186, 3436)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '11_8', '11_7'])
           ];
         end;
       end;

     LOC_VW_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Varrock West Mine';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Varrock West Mine North';
           tileBox := intToBox(3180, 3370, 3186, 3380);
           objects := [ROCK_TIN, ROCK_CLAY, ROCK_IRON];
         end;

         with subLocs[1] do
         begin
           name := 'Varrock West Mine South';
           tileBox := intToBox(3172, 3362, 3180, 3372);
           objects := [ROCK_TIN, ROCK_SILVER]
         end;
       end;

     LOC_GE_OAKS:
       with MSI_Locations[loc] do
       begin
         name := 'Grand Exchange Oaks';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Grand Exchange Oaks';
           tileBox := intToBox(3191, 3458, 3195, 3465);
           compass := randomRange(260, 290);
           camera := false;
           objects := MSI_Scripts[SCRIPT_GE_OAKS].Defaults.Trees;
         end;
       end;

     LOC_GE_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Grand Exchange Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Grand Exchange Bank';
           tileBox := intToBox(3173, 3475, 3181, 3482);
           compass := randomRange(75, 105);
           camera := false;
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_GE_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_GE_BANK;

           reflection := [
             TPointArray([point(3222, 3217), point(3260, 3227),
                          point(3239, 3280), point(3241, 3329),
                          point(3212, 3378), point(3212, 3426),
                          point(3178, 3478)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '11_8', '11_7', '11_6'])
           ];
         end;
       end;

     LOC_GE_YEWS:
       with MSI_Locations[loc] do
       begin
         name := 'Grand Exchange Yews';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Grand Exchange Yews West';
           tileBox := intToBox(3218, 3501, 3225, 3508);
           compass := randomRange(305, 360);
         end;

         with subLocs[1] do
         begin
           name := 'Grand Exchange Yews East';
           tileBox := intToBox(3204, 3501, 3211, 3506);
           compass := 320;
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].camera := false;
           subLocs[i].objects := MSI_Scripts[SCRIPT_GE_YEWS].Defaults.Trees;
         end;
       end;

     LOC_DB_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Draynor Village Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Draynor Village Bank';
           tileBox := intToBox(3090, 3240, 3097, 3246);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_DB_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_DB_BANK;

           reflection := [
             TPointArray([point(3222, 3216), point(3092, 3243)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '10_9'])
           ];
         end;
       end;

     LOC_DB_WILLOWS:
       with MSI_Locations[loc] do
       begin
         name := 'Draynor Village Willows';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Draynor Village Willows';
           tileBox := intToBox(3084, 3225, 3090, 3238);
           objects := MSI_Scripts[SCRIPT_DB_WILLOWS].Defaults.Trees;
         end;
       end;

     LOC_DB_TREES:
       with MSI_Locations[loc] do
       begin
         name := 'Draynor Village Trees';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Draynor Village Trees';
           tileBox := intToBox(3075, 3265, 3085, 3275);
           objects := MSI_Scripts[SCRIPT_DB_TREES].Defaults.Trees;
         end;
       end;

     LOC_DB_OAKS:
       with MSI_Locations[loc] do
       begin
         name := 'Draynor Village Oaks';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Draynor Village Oaks West';
           tileBox := intToBox(3099, 3239, 3103, 3245);
           compass := randomRange(300, 360);
         end;

         with subLocs[1] do
         begin
           name := 'Draynor Village Oaks East';
           tileBox := intToBox(3105, 3243, 3109, 3247);
           compass := randomRange(260, 350);
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].camera := false;
           subLocs[i].objects := MSI_Scripts[SCRIPT_DB_OAKS].Defaults.Trees;
         end;
       end;

     LOC_DB_FISH:
       with MSI_Locations[loc] do
       begin
         name := 'Draynor Village Fishing Spots';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Draynor Village Fishing Spots';
           tileBox := intToBox(3084, 3223, 3089, 3233);
           objects := MSI_Scripts[SCRIPT_DB_FISHER].Defaults.FishSpots;
         end;
       end;

     LOC_DB_CLAY:
       with MSI_Locations[loc] do
       begin
         name := 'Draynor Village Clay Mine';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Draynor Village Clay Mine';
           tileBox := intToBox(3138, 3314, 3145, 3321);
           objects := MSI_Scripts[SCRIPT_DB_CLAY].Defaults.Rocks;
         end;
       end;

     LOC_DB_YEWS:
       with MSI_Locations[loc] do
       begin
         name := 'Draynor Village Yews';
         atBank := false;

         setLength(subLocs, 3);
         with subLocs[0] do
         begin
           name := 'Draynor Village Yews West';
           tileBox := intToBox(3149, 3228, 3154, 3233);
           compass := 90;
         end;

         with subLocs[1] do
         begin
           name := 'Draynor Village Yews Central';
           tileBox := intToBox(3164, 3219, 3172, 3224);
           compass := 90;
         end;

         with subLocs[2] do
         begin
           name := 'Draynor Village Yews East';
           tileBox := intToBox(3183, 3222, 3188, 3228);
           compass := 180;
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].camera := false;
           subLocs[i].objects := MSI_Scripts[SCRIPT_DB_YEWS].Defaults.Trees;
         end;
       end;

     LOC_RM_YEWS:
       with MSI_Locations[loc] do
       begin
         name := 'Rimmington Yews';
         atBank := false;

         setLength(subLocs, 4);
         with subLocs[0] do
         begin
           name := 'Rimmington Yews East';
           tileBox := intToBox(2937, 3230, 2942, 3236);
           compass := randomRange(280, 360);
         end;

         with subLocs[1] do
         begin
           name := 'Rimmington Yews Central';
           tileBox := intToBox(2931, 3231, 2937, 3237);
           compass := randomRange(60, 225);
         end;

         with subLocs[2] do
         begin
           name := 'Rimmington Yews West';
           tileBox := intToBox(2926, 3226, 2931, 3231);
           compass := randomRange(20, 55);
         end;

         with subLocs[3] do
         begin
           name := 'Rimmington Yews South';
           tileBox := intToBox(2933, 3225, 2938, 3230);
           compass := randomRange(280, 360);
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].camera := false;
           subLocs[i].objects := [TREE_YEW_NEW];
         end;
       end;

     LOC_RM_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Rimmington Mine';
         atBank := false;

         setLength(subLocs, 4);
         with subLocs[0] do
         begin
           name := 'Rimmington Mine North';
           tileBox := intToBox(2975, 3244, 2981, 3248);
           objects := [ROCK_COPPER];
         end;

         with subLocs[1] do
         begin
           name := 'Rimmington Mine East';
           tileBox := intToBox(2983, 3233, 2988, 3242);
           objects := [ROCK_CLAY, ROCK_TIN];
         end;

         with subLocs[2] do
         begin
           name := 'Rimmington Mine South';
           tileBox := intToBox(2973, 3229, 2985, 3238);
           objects := [ROCK_IRON, ROCK_GOLD]
         end;

         with subLocs[3] do
         begin
           name := 'Rimmington Mine West';
           tileBox := intToBox(2967, 3236, 2971, 3243);
           objects := [ROCK_IRON];
         end;
       end;

     LOC_RM_WILLOWS:
       with MSI_Locations[loc] do
       begin
         name := 'Rimmington Willows';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Rimmington Willows';
           tileBox := intToBox(2996, 3160, 3006, 3169);
           objects := [TREE_WILLOW_NEW];
         end;
       end;

     LOC_FE_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Falador East Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Falador East Bank';
           tileBox := intToBox(3009, 3355, 3017, 3358);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_FE_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_FE_BANK;

           reflection := [
             TPointArray([point(3222, 3217), point(3209, 3203),
                          point(3073, 3275), point(3006, 3278),
                          point(3006, 3359), point(3013, 3355)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '10_9', '10_8', '9_8', '9_7'])
           ];
         end;
       end;

     LOC_FW_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Falador West Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Falador West Bank';
           tileBox := intToBox(2943, 3366, 2950, 3371);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_FW_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_FW_BANK;

           reflection := [
             TPointArray([point(3222, 3217), point(3209, 3203),
                          point(3073, 3275), point(3006, 3278),
                          point(3006, 3359), point(2965, 3380),
                          point(2946, 3368)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '10_9', '10_8', '9_8', '9_7', '8_7'])
           ];
         end;
       end;

     LOC_FW_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Falador West Mine';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Falador West Mine North';
           tileBox := intToBox(2907, 3360, 2911, 3367);
           objects := [ROCK_COAL, ROCK_COPPER];
         end;

         with subLocs[1] do
         begin
           name := 'Falador West Mine South';
           tileBox := intToBox(2903, 3352, 2909, 3360);
           objects := [ROCK_TIN, ROCK_IRON];
         end;
       end;

     LOC_FW_PUMP:
       with MSI_Locations[loc] do
       begin
         name := 'Falador WaterPump';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Falador WaterPump';
           tileBox := intToBox(2946, 3380, 2950, 3385);
           objects := MSI_Scripts[SCRIPT_FW_FILLER].Defaults.Objects;
         end;
       end;

     LOC_PS_WILLOWS:
       with MSI_Locations[loc] do
       begin
         name := 'Port Sarim Willows';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Port Sarim Willows South';
           tileBox := intToBox(3055, 3243, 3063, 3255);
         end;

         with subLocs[1] do
         begin
           name := 'Port Sarim Willows North';
           tileBox := intToBox(3060, 3254, 3066, 3263);
         end;

         for i := 0 to high(subLocs) do
           subLocs[i].objects := [TREE_WILLOW_NEW];
       end;

     LOC_PS_YEWS:
       with MSI_Locations[loc] do
       begin
         name := 'Port Sarim Yews';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Port Sarim Yews East';
           tileBox := intToBox(3050, 3268, 3054, 3274);
           compass := 280;
         end;

         with subLocs[1] do
         begin
           name := 'Port Sarim Yews West';
           tileBox := intToBox(3041, 3269, 3046, 3274);
           compass := 80;
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].camera := false;
           subLocs[i].objects := MSI_Scripts[SCRIPT_PS_YEWS].Defaults.Trees;
         end;
       end;

     LOC_PS_DBOX:
       with MSI_Locations[loc] do
       begin
         name := 'Port Sarim Deposit Box';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Port Sarim Deposit Box';
           tileBox := intToBox(3043, 3234, 3052, 3238);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_PS_DBOX';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_PS_DBOX;

           reflection := [
             TPointArray([point(3223, 3217), point(3210, 3203),
                          point(3110, 3223), point(3072, 3274),
                          point(3064, 3273), point(3048, 3234)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '10_9', '9_9'])
           ];
         end;
       end;

     LOC_LSW_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Lumbridge Swamp West Mine';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Lumbridge Swamp West Mine';
           tileBox := intToBox(3143, 3142, 3150, 3150);
           objects := MSI_Scripts[SCRIPT_LSW_MINER].Defaults.Rocks;
         end;
       end;

     LOC_LSE_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Lumbridge Swamp East Mine';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Lumbridge Swamp East Mine';
           tileBox := intToBox(3223, 3144, 3233, 3151);
           objects := MSI_Scripts[SCRIPT_LSE_MINER].Defaults.Rocks;
         end;
       end;

     LOC_LB_SPAWN:
       with MSI_Locations[loc] do
       begin
         name := 'Lumbridge Courtyard';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Lumbridge Courtyard';
           tileBox := intToBox(3216, 3210, 3227, 3225);
         end;
       end;

     LOC_EV_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Edgeville Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Edgeville Bank';
           tileBox := intToBox(3091, 3488, 3096, 3494);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_EV_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_EV_BANK;

           reflection := [
             TPointArray([point(3222, 3217), point(3236, 3217),
                          point(3215, 3276), point(3121, 3297),
                          point(3077, 3329), point(3094, 3491)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '11_8', '10_8', '10_7', '10_6'])
           ];
         end;
       end;

     LOC_EV_YEWS:
       with MSI_Locations[loc] do
       begin
         name := 'Edgeville Yews';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Edgeville Yews South';
           tileBox := intToBox(3085, 3469, 3089, 3474);
           compass := randomRange(170, 190);
         end;

         with subLocs[1] do
         begin
           name := 'Edgeville Yews North';
           tileBox := intToBox(3085, 3476, 3089, 3480);
           compass := 275;
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].camera := false;
           subLocs[i].objects := MSI_Scripts[SCRIPT_EV_YEWS].Defaults.Trees;
         end;
       end;

     LOC_EV_WELL:
       with MSI_Locations[loc] do
       begin
         name := 'Edgeville Well';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Edgeville Well';
           tileBox := intToBox(3081, 3498, 3087, 3503);
           objects := MSI_Scripts[SCRIPT_EV_SOFTENER].Defaults.Objects;
         end;
       end;

     LOC_BBV_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Barbarian Village Mine';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Barbarian Village Mine';
           tileBox := intToBox(3077, 3417, 3086, 3425);
           objects := MSI_Scripts[SCRIPT_BBV_MINER].Defaults.Rocks;
         end;
       end;

     LOC_BBV_FISH:
       with MSI_Locations[loc] do
       begin
         name := 'Barbarian Village Fishing Spots';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Barbarian Fishing North';
           tileBox := intToBox(3108, 3429, 3112, 3437);
         end;

         with subLocs[1] do
         begin
           name := 'Barbarian Fishing South';
           tileBox := intToBox(3101, 3423, 3104, 3428);
         end;

         for i := 0 to high(subLocs) do
         begin
           subLocs[i].objects := MSI_Scripts[SCRIPT_BBV_FISHER].Defaults.FishSpots;
           subLocs[i].camera  := true;
           subLocs[i].compass := 270;
         end;
       end;

     LOC_SV_MAGICS:
       with MSI_Locations[loc] do
       begin
         name := 'Seers Village Magic Trees';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do //East trees
         begin
           name := 'Seers Village East Magic Trees';
           tileBox := intToBox(2695, 3395, 2701, 3403);
         end;

         with subLocs[1] do //West trees
         begin
           name := 'Seers Village West Magic Trees';
           tileBox := intToBox(2701, 3394, 2705, 3402);
         end;

         for i := 0 to high(subLocs) do
           subLocs[i].objects := MSI_Scripts[SCRIPT_SV_MAGICS].Defaults.Trees;
       end;

     LOC_SV_OAKS:
       with MSI_Locations[loc] do
       begin
         name := 'Seers Village Oak Trees';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Seers Village Oak Trees';
           tileBox := intToBox(2715, 3478, 2722, 3486);
           objects := MSI_Scripts[SCRIPT_SV_OAKS].Defaults.Trees;
         end;
       end;

     LOC_SV_TREES:
       with MSI_Locations[loc] do
       begin
         name := 'Seers Village Trees';
         atBank := False;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Seers Village Trees';
           tileBox := intToBox(2707, 3435, 2729, 3455);
           objects := MSI_Scripts[SCRIPT_SV_TREES].Defaults.Trees;
         end;
       end;

     LOC_SV_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Seers Village Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Seers Village Bank';
           tileBox := intToBox(2719, 3491, 2729, 3496);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_SV_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_SV_BANK;

           reflection := [TPointArray([])];

           spsAreas := [];
         end;
       end;

     LOC_SV_MAPLES:
       with MSI_Locations[loc] do
       begin
         name := 'Seers Village Maples';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Seers Village West Maples';
           tileBox := intToBox(2717, 3499, 2727, 3506);
           objects := MSI_Scripts[SCRIPT_SV_MAPLES].Defaults.Trees;
         end;

         with subLocs[1] do
         begin
           name := 'Seers Village East Maples';
           tileBox := intToBox(2728, 3500, 2733, 3505);
         end;

         for i := 0 to high(subLocs) do
           subLocs[i].objects := MSI_Scripts[SCRIPT_SV_MAPLES].Defaults.Trees;
       end;

     LOC_SV_YEWS:
       with MSI_Locations[loc] do
       begin
         name := 'Seers Village Yews';
         atBank := false;

         setLength(subLocs, 2);
         with subLocs[0] do
         begin
           name := 'Seers Village East Yew';
           tileBox := intToBox(2710, 3458, 2716, 3464);
         end;

         with subLocs[1] do
         begin
           name := 'Seers Village West Yews';
           tileBox := intToBox(2702, 3458, 2706, 3469);
         end;

         for i := 0 to high(subLocs) do
           subLocs[i].objects := MSI_Scripts[SCRIPT_SV_YEWS].Defaults.Trees;
       end;

     LOC_GUILD_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Mining Guild';
         atBank := false;

         setLength(subLocs, 3);
         with subLocs[0] do
         begin
           name := 'Mining Guild West';
           tileBox := intToBox(3016, 9736, 3025, 9743);
           objects := [ROCK_COAL];
         end;

         with subLocs[1] do
         begin
           name := 'Mining Guild Central';
           tileBox := intToBox(3027, 9731, 3041, 9743);
           objects := [ROCK_COAL];
         end;

         with subLocs[2] do
         begin
           name := 'Mining Guild East';
           tileBox := intToBox(3042, 9732, 3054, 9745);
           objects := [ROCK_COAL, ROCK_MITHRIL];
         end;
       end;

     LOC_CG_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Crafting Guild Mine';
         atBank := false;

         setLength(subLocs, 3);
         with subLocs[0] do
         begin
           name := 'Crafting Guild Gold';
           tileBox := intToBox(2938, 3276, 2943, 3282);
           compass := randomRange(60, 190);
           camera := true;
           objects := [ROCK_GOLD];
         end;

         with subLocs[1] do
         begin
           name := 'Crafting Guild Clay';
           tileBox := intToBox(2938, 3282, 2943, 3285);
           objects := [ROCK_CLAY];
         end;

         with subLocs[2] do
         begin
           name := 'Crafting Guild Silver';
           tileBox := intToBox(2939, 3285, 2943, 3291);
           compass := randomRange(315, 360);
           camera := true;
           objects := [ROCK_SILVER];
         end;
       end;

     LOC_AK_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Al Kharid Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Al Kharid Bank';
           tileBox := intToBox(3268, 3161, 3272, 3173);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_AK_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_AK_BANK;

           reflection := [
             TPointArray([point(3222, 3217), point(3236, 3218),
                          point(3245, 3166), point(3270, 3165)])
           ];

           spsAreas   := [
             TStringArray(['11_9', '12_9'])
           ];
         end;
       end;

     LOC_AK_RANGE:
       with MSI_Locations[loc] do
       begin
         name := 'Al Kharid Cooking Range';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Al Kharid Cooking Range';
           spsBox := intToBox(4905, 3908, 4923, 3928);
           objects := MSI_Scripts[SCRIPT_AK_COOKER].Defaults.CookingSpot;
         end;
       end;

     LOC_AK_MINE:
       with MSI_Locations[loc] do
       begin
         name := 'Al Kharid Mine';
         atBank := false;

         setLength(subLocs, 3);
         with subLocs[0] do
         begin
           name := 'Al Kharid Mine South';
           tileBox := intToBox(3295, 3284, 3302, 3290);
           objects := [ROCK_GOLD, ROCK_IRON];
         end;

         with subLocs[1] do
         begin
           name := 'Al Kharid Mine Central';
           tileBox := intToBox(3293, 3296, 3303, 3307);
           objects := [ROCK_SILVER, ROCK_MITHRIL, ROCK_IRON, ROCK_COAL];
         end;

         with subLocs[2] do
         begin
           name := 'Al Kharid Mine North';
           tileBox := intToBox(3297, 3308, 3305, 3318);
           objects := [ROCK_SILVER, ROCK_MITHRIL, ROCK_IRON, ROCK_TIN,
                       ROCK_ADAMANTITE, ROCK_COPPER];
         end;
       end;

     LOC_KJ_STILES:
       with MSI_Locations[loc] do
       begin
         name := 'Stiles On Karamja';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Stiles On Karamja';
           tileBox := intToBox(2849, 3140, 2853, 3145);
         end;
       end;

     LOC_KJ_FISH:
       with MSI_Locations[loc] do
       begin
         name := 'Karamja Fishing Spot';
         atBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Karamja Fishing Spot';
           tileBox := intToBox(2922, 3173, 2927, 3180);
           objects := MSI_Scripts[SCRIPT_KJ_NOTER].Defaults.FishSpots;
         end;
       end;

     LOC_CB_BANK:
       with MSI_Locations[loc] do
       begin
         name := 'Catherby Bank';
         atBank := true;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Catherby Bank';
           tileBox := intToBox(2805, 3439, 2811, 3443);
         end;

         with deathPath do
         begin
           name := 'LOC_LB_SPAWN to LOC_CB_BANK';
           startLoc := LOC_LB_SPAWN;
           endLoc := LOC_CB_BANK;

           reflection := [TPointArray([])];
           spsAreas := [];
         end;
       end;

     LOC_CB_FISH:
       with MSI_Locations[loc] do
       begin
         name := 'Catherby Fishing Spots';
         atBank := false;

         setLength(subLocs, 4);
         with subLocs[0] do
         begin
           name := 'Catherby East Fishing Spot';
           tileBox := intToBox(2832, 3429, 2839, 3434);
         end;

         with subLocs[1] do
         begin
           name := 'Catherby East/Central Fishing Spot';
           tileBox := intToBox(2841, 3426, 2847, 3433);
         end;

         with subLocs[2] do
         begin
           name := 'Catherby West/Central Fishing Spot';
           tileBox := intToBox(2849, 3421, 2855, 3427);
         end;

         with subLocs[3] do
         begin
           name := 'Catherby West Fishing Spot';
           tileBox := intToBox(2856, 3424, 2861, 3430);
         end;

         for i := 0 to high(subLocs) do
           subLocs[i].objects := MSI_Scripts[SCRIPT_CB_FISHER].Defaults.FishSpots;
       end;

     LOC_ALTER_AIR:
       with MSI_Locations[loc] do
       begin
         Name := 'Air Alter';
         AtBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Air Alter';
           tileBox := intToBox(2835, 4825, 2846, 4835);
           objects := MSI_Scripts[SCRIPT_RC_AIR].Defaults.Objects;
         end;
       end;

     LOC_ALTER_EARTH:
       with MSI_Locations[loc] do
       begin
         Name := 'Earth Alter';
         AtBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Earth Alter';
           tileBox := intToBox(2652, 4834, 2662, 4844);
           objects := MSI_Scripts[SCRIPT_RC_EARTH].Defaults.Objects;
         end;
       end;

     LOC_ALTER_FIRE:
       with MSI_Locations[loc] do
       begin
         Name := 'Fire Alter';
         AtBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Fire Alter';
           tileBox := intToBox(2578, 4835, 2588, 4845);
           objects := MSI_Scripts[SCRIPT_RC_FIRE].Defaults.Objects;
         end;
       end;

     LOC_ALTER_WATER:
       with MSI_Locations[loc] do
       begin
         Name := 'Water Alter';
         AtBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Water Alter';
           tileBox := intToBox(3483, 4830, 3491, 4838);
           objects := MSI_Scripts[SCRIPT_RC_WATER].Defaults.Objects;
         end;
       end;

     LOC_ALTER_MIND:
       with MSI_Locations[loc] do
       begin
         Name := 'Mind Alter';
         AtBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Mind Alter';
           tileBox := intToBox(2783, 4835, 2790, 4843);
           objects := MSI_Scripts[SCRIPT_RC_MIND].Defaults.Objects;
         end;
       end;

     LOC_ALTER_BODY:
       with MSI_Locations[loc] do
       begin
         Name := 'Body Alter';
         AtBank := false;

         setLength(subLocs, 1);
         with subLocs[0] do
         begin
           name := 'Body Alter';
           tileBox := intToBox(2518, 4836, 2527, 4844);
           objects := MSI_Scripts[SCRIPT_RC_BODY].Defaults.Objects;
         end;
       end;
  end;

  with MSI_Locations[loc] do
  begin
    constant := loc;

    // set all path leg's surfaces to RUNESCAPE_SURFACE if not already set
    {$IFDEF SPS}
    if (deathPath.name <> '') then
    begin
      if (length(deathPath.spsAreas) <> length(deathPath.reflection)) then
        MSI_Debug('WARNING: Invalid SPSAreas length for location: '+name);

      if (length(deathPath.spsSurfaces) <= 0) then
      begin
        setLength(deathPath.spsSurfaces, length(deathPath.reflection));

        for i := 0 to high(deathPath.spsSurfaces) do
          deathPath.spsSurfaces[i] := RUNESCAPE_SURFACE;
      end;
    end;
    {$ENDIF}

    for i := 0 to high(subLocs) do
    begin
      // if compass isn't set, set to default
      if (varType(subLocs[i].compass) = 0) then
      begin
        subLocs[i].compass := 0;
        subLocs[i].camera := true;
      end;
    end;
  end;

  result := (MSI_Locations[loc].Name <> '');
end;

(*
MSI_LoadAllLocations
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  procedure MSI_LoadAllLocations;

Loads all the locations into the MSI_Locations array.  This procedure should
only be called in MSI_Setup.

.. note::

  | Author: Coh3n
  | Last Updated: 02 August 2010 by Coh3n

*)
procedure MSI_LoadAllLocations;
var
  i: Integer;
begin
  for i := 0 to High(MSI_Locations) do
    MSI_LoadLocation(i);
end;

(*
MSI_SetPlayerLoc
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_SetPlayerLoc(): boolean;

Set's the player's location.  Checks the script's starting and ending locations.
If the player isn't at either, it won't set the player's location.

.. note::

  | Author: NCDS
  | Last Updated: 06 September 2011 by Coh3n

Example:

.. code-block:: pascal

  MSI_SetPlayerLoc();
*)
function MSI_SetPlayerLoc(): boolean;
var
  i: Integer;
  locArr: TIntegerArray;
  Script: TScript;
begin
  if (not LoggedIn) then
    Exit;

  MSI_AddHeader('MSI_SetPlayerLoc');

  with MSI_Players[CurrentPlayer] do
  begin
    Script := MSI_Scripts[Scripts[CurrentScript].Name];
    SetLength(locArr, 2);
    locArr[0] := Script.PathInfo.StartLoc;
    locArr[1] := Script.PathInfo.EndLoc;

    for i := 0 to 1 do
      if (MSI_AtLocation(locArr[i], false)) then
      begin
        Location := locArr[i];
        result := true;
        break;
      end else
        if (i = 1) then
          if (not MSI_WalkPath(script.pathInfo, (invCount < 15) or ((invCount > 15) and (script.skillConst = SKILL_RUNECRAFTING)))) then
            result := MSI_DeathWalk()
          else
            result := true;

    if (result) then
      MSI_Debug('Player''s location: '+MSI_Locations[Location].Name)
    else
      MSI_Debug('Failed to get player''s location');
  end;

  MSI_CloseHeader('MSI_SetPlayerLoc: '+boolToStr(result));
end;

(*
MSI_ValidSubLoc
~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_ValidSubLoc(loc: TLocation; subIndex: integer): boolean;

Returns true if the player is autoing an object that appears in the sub location
of the location 'loc' and sub location element 'subIndex'.


.. note::

  | Author: Coh3n
  | Last Updated: 07 September 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_ValidSubLoc(MSI_Locations[LOC_VE_BANK], i)) then
    MSI_Relocate(LOC_VE_BANK);
*)
function MSI_ValidSubLoc(loc: TLocation; subIndex: integer): boolean;
var
  i: integer;
  objs: TIntegerArray;
  exceptions: TIntegerArray;
begin
  result := loc.atBank; // always valid if the location is a bank

  // spawning point is valid; if more locations are added, an array should be used
  exceptions := [LOC_LB_SPAWN, LOC_KJ_STILES];
  if (not result) then
    result := (inIntArray(exceptions, loc.constant));

  if (not result) then
  begin
    objs := MSI_GetPlayerObjects();

    for i := 0 to high(loc.subLocs[subIndex].objects) do
      if (inIntArray(objs, loc.subLocs[subIndex].objects[i])) then
      begin
        result := true;
        break;
      end;
  end;

  if (not result) then
    MSI_SubDebug('MSI_ValidSubLoc ('+loc.subLocs[subIndex].name+'): '+toStr(result));
end;

(*
MSI_GetLocBox
~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_GetLocBox(loc: TLocation): TBox;

Gets the corrent box (either SPS or tile) from the location 'loc'.

.. note::

  | Author: Coh3n
  | Last Updated: 04 October 2011 by Coh3n

Example:

.. code-block:: pascal

  mmBox := MSI_GetLocBox(MSI_Locations[LOC_VE_BANK]);
*)
function MSI_GetLocBox(loc: TLocation; subLoc: integer): TBox;
begin
  if (MSI_HookBroken[HOOK_WALKING]) then
    if (loc.subLocs[subLoc].spsBox.x1 = 0) then
      result := MSI_ConvertTileBox(loc.subLocs[subLoc].tileBox)
    else
      result := loc.subLocs[subLoc].spsBox
  else
    result := loc.subLocs[subLoc].tileBox;
end;

(*
MSI_Relocate
~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_Relocate(Loc: Integer): Boolean;

Relocates the player to the location 'Loc'. Only relocates if the player is
near the location. Returns true if relocation was successful.

.. note::

  | Author: Coh3n and NCDS
  | Last Updated: 21 August 2011 by NCDS

Example:

.. code-block:: pascal

  if (MSI_Relocate(LOC_VE_MINE)) then
    MSI_Debug('Successfully relocated');
*)
function MSI_Relocate(Loc: Integer): Boolean;
var
  hSubLoc, i, cP: integer;
  mPos: TPoint;
  areaTPA: TPointArray;
  local_subLocs: TSubLocArray;
  box: TBox;
begin
  if (not loggedIn) then
    exit;

  MSI_AddHeader('MSI_Relocate (' + MSI_Locations[loc].Name + ')');

  if (Length(MSI_Locations[loc].subLocs) < 1) then
  begin
    MSI_Debug('No relocation points for ' + MSI_Locations[loc].Name);
    result := true;
  end;

  if (not result) then
  begin
    mPos := MSI_GetMyPos();

    with MSI_Locations[Loc] do
    begin
      // check to see if player's in the last box, if so, invert the boxes
      cP := MSI_Players[CurrentPlayer].CurrentPoint;
      hSubLoc := high(subLocs);

      if (cP = hSubLoc) then
      begin
        setLength(local_subLocs, (hSubLoc + 1));

        for i := hSubLoc downto 0 do
          local_subLocs[hSubLoc - i] := subLocs[i];

        subLocs := local_subLocs;
        cp := (hSubLoc - cP);
      end;

      MSI_Players[CurrentPlayer].CurrentPoint := cP;

      // loop through each "subLoc"
      for i := cP to hSubLoc do
      begin
        // no point in relocating to a location that doesn't have the object we want
        if (not MSI_ValidSubLoc(MSI_Locations[loc], i)) then
          continue;

        box := MSI_GetLocBox(MSI_Locations[loc], i);

        // if player is already in box, continue
        if (pointInBox(mPos, box)) then
        begin
          MSI_BoxToMM(box);
          MSI_Debug('At sub-location ' + subLocs[i].name);
          result := true;

          continue;
        end;

        MSI_FindRandoms(true);

        result := MSI_WalkPoint(middleBox(box), 10);

        if (not result) then
        begin
          // create a TPA from the subLoc's box
          areaTPA := TPAFromBox(box);
          sortTPAfrom(areaTPA, mPos);

          // trying walking to the centre point, then closest
          if (length(areaTPA) > 0) then
            if (MSI_WalkPoint(middleTPA(areaTPA), 10)) or (MSI_WalkPoint(areaTPA[0], 10)) then
            begin
              result := true;
              break;
            end;
        end;

        if (result) then
        begin
          MSI_Debug('Relocating to sub-location: ' + subLocs[i].name);

          setAngle(subLocs[i].camera);
          makeCompass(subLocs[i].compass);

          cP := i;
          MSI_Flag(0);
          break;
        end else
          cP := 0;
      end;
    end;
  end;

  MSI_Players[CurrentPlayer].CurrentPoint := cP;
  MSI_CloseHeader('MSI_Relocate: ' + boolToStr(result));
end;

(*
MSI_AtLocation
~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_AtLocation(loc: integer; relocate: boolean): boolean;

Returns true if the player is at the location 'Loc'. Works with both reflection
and SPS. If the player isn't at the location and 'Relocate' is set to true,
will call MSI_Relocate.

.. note::

  | Author: Coh3n
  | Last Updated: 27 August 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_AtLocation(LOC_VE_BANK, True)) then
    MSI_Debug('We are at Varrock East Bank');
*)
function MSI_AtLocation(loc: integer; relocate: boolean): boolean;
var
  i: integer;
  box: TBox;
  mPos: TPoint;
begin
  if (not loggedIn) then
    exit;

  MSI_AddHeader('MSI_AtLocation');

  if (loc = LOC_POWER_SKILL) then
  begin
    MSI_Debug('Powerskilling, no defined location');
    result := true;
  end;

  if (not(result)) then
  begin
    mPos := MSI_GetMyPos();

    with MSI_Locations[loc] do
    begin
      for i := 0 to high(subLocs) do
      begin
        if (not MSI_ValidSubLoc(MSI_Locations[loc], i)) then
          continue;

        MSI_Debug('Checking sub-location: ' + subLocs[i].name);

        box := MSI_GetLocBox(MSI_Locations[loc], i);

        if (pointInBox(mPos, box)) then
        begin
          MSI_BoxToMM(box);
          result := true;

          MSI_Debug('Player is at ' + subLocs[i].name);
          break;
        end else
          if (i = high(subLocs)) then
            if (relocate) then
              result := MSI_Relocate(loc);
      end;

      if (not Result) then
        MSI_Debug('Player not at ' + name);

      MSI_Players[CurrentPlayer].Location := constant;
    end;
  end;

  MSI_CloseHeader('MSI_AtLocation: ' + boolToStr(result));
end;

