{==============================================================================\
|                         MSI Group Scripting Include                          |
|                               Globals.scar                                   |
|==============================================================================|
| Used to store all necessary global types, consts and vars                    |
|                                                                              |
| * function MSI_LoadColorArea(): Boolean;      * by The MSI Team              |
| * procedure MSI_LoadAllColorAreas;            * by Coh3n                     |
| * function MSI_RelocateColor(): Boolean;      * by marpis                    |
| * function MSI_RelocateRef(): Boolean;        * by Coh3n                     |
| * function MSI_Relocate(): Boolean;           * by Coh3n & Sir R. Magician   |
 \_____________________________________________________________________________}

{******************************************************************************}
{ function MSI_LoadColorArea(Area: Integer): Boolean;                          }
{ By: The MSI Team                                                             }
{ Date: 07 November 2010                                                       }
{ Description: Loads the minimap color area 'Area'                             }
{******************************************************************************}
function MSI_LoadColorArea(Area: Integer): Boolean;
begin
  case Area of
    AREA_GE_YEWS_1:
      with MSI_ColorAreas[Area] do
      begin
      end;

    AREA_GE_YEWS_2:
      with MSI_ColorAreas[Area] do
      begin
      end;

    AREA_RM_YEWS_1:
      with MSI_ColorAreas[Area] do
      begin
      end;

    AREA_RM_YEWS_2:
      with MSI_ColorAreas[Area] do
      begin
      end;
  end;

  Result := (MSI_ColorAreas[Area].Name <> '');
end;

{******************************************************************************}
{ procedure MSI_LoadAllColorAreas;                                             }
{ By: Coh3n                                                                    }
{ Date: 07 November 2010                                                       }
{ Description: Loads all the color areas into the global array                 }
{******************************************************************************}
procedure MSI_LoadAllColorAreas;
var
  i: Integer;
begin
  for i := 0 to High(MSI_ColorAreas) do
    MSI_LoadColorArea(i);
end;

{******************************************************************************}
{ function MSI_SwitchGETrees: Boolean;                                         }
{ By: LordSaturn                                                               }
{ Date: 05 November 2010                                                       }
{ Description: Switchs Trees at the Grand Exchange location                    }
{******************************************************************************}
function MSI_SwitchGETrees: Boolean;
var
  c, d1, d2, mn: integer;
  Pt: TPoint;
  P: TPointArray;
  s, s2: string;
begin
  if not LoggedIn then Exit;
  while not Result do
  begin
    Inc(c);
    FindSymbols(P, 'tree');
    P := MSI_RemovePointsInBox(P, inttobox(MMX1, MMCY+20, MMX2, MMY2));
    if Length(P) <> 3 then Exit;
    SortTPAFrom(P, Point(MMX1, MMY1));
    d1 := Distance(MMCX, MMCY, P[0].x, P[0].y);
    d2 := Distance(MMCX, MMCY, P[2].x, P[2].y);
    mn := Min(d1, d2);
    case mn of
      d1: s := 'd1';
      d2: s := 'd2';
    end;
    if c = 2 then
    begin
      Result := s2 <> s;
      case MSI_Players[CurrentPlayer].Scripts[CurrentScript].LeftTree of
        True: MSI_Players[CurrentPlayer].Scripts[CurrentScript].LeftTree := False;
        False: MSI_Players[CurrentPlayer].Scripts[CurrentScript].LeftTree := True;
      end;
      Exit;
    end;
    s2 := s;
    if mn = d2 then
    begin
      Pt := MiddleTPA([P[0], P[1]]);
      IncEx(Pt.y, 8);
    end else
      Pt := Point(P[2].x-8, P[2].y+2);
    Mouse(Pt.x, Pt.y, 2, 2, True);

    MSI_Flag(FlagDistance);
  end;
end;

{******************************************************************************}
{ function MSI_RelocateColor(...): Boolean;                                    }
{ By: marpis                                                                   }
{ Description: Finds a location in minimap. First tries to find DTM, then      }
{              colors, and if still not found it will find it by symbol        }
{******************************************************************************}
function MSI_RelocateColor(var P: TPoint; Location, Index: Integer): Boolean;
Var
  SA, EA, tmp_Ang: Extended;
  N, I, II, III, H, HH, X, Y, Score, Step: Integer;
  ATPA: T2DPointArray;
  tmp_TPA: TPointArray;
  X1, Y1, X2, Y2, ScriptConst: Integer;
  Loc: TMMColorArea;
begin
  P := Point(-1, -1);

  if (not LoggedIn) then
    Exit;

  ScriptConst := MSI_Players[CurrentPlayer].Scripts[CurrentScript].Name;

  case ScriptConst of
    SCRIPT_GE_YEWS:
      if (MSI_SwitchGETrees) then
      begin
        Result := True;
        Exit;
      end;
  end;

  if (Length(MSI_Locations[Location].RelocateAreas) <= 0) then
  begin
    MSI_SubDebug('No relocation areas for ' + MSI_Locations[Location].Name);
    Exit;
  end;

  Loc := MSI_ColorAreas[MSI_Locations[Location].RelocateAreas[Index]];
  Step := (Loc.W * Loc.H) / 10;

  // DTM Search
  if (Loc.DTM > -1) then
    while (N < 10) do
    begin
      if FindDTMRotated(Loc.DTM, X, Y, MMX1, MMY1, MMX2, MMY2, SA, EA, 0.02, tmp_Ang) then
      begin
        Result := True;
        P := Point(X, Y);
        MSI_SubDebug('Found relocation point via DTM: (' + IntToStr(P.X) + ', ' + IntToStr(P.Y) + ')');
        Exit;
      end;
      Inc(N);
      SA := SA - (N * 0.02);
      EA := EA + (N * 0.02);
    end;

  // Color search
  if (Length(Loc.Colors) > 0) then
  begin
    H := High(Loc.Colors);
    SetLength(ATPA, H + 1);

    for I := 0 to H do
    begin
      FindColorsSpiralTolerance(MMCX, MMCY, ATPA[I], Loc.Colors[I], MMX1, MMY1, MMX2, MMY2, Loc.Tolerances[I]);
      FilterPointsPie(ATPA[I], 0.0, 360.0, 0.0, 76.0, MMCX, MMCY);
    end;

    // Go through every TPA that contains one color.
    for I := 0 to H do
    begin
      HH := High(ATPA[I]);

      // Go through every 10th point in ATPA[I] to avoid lag.
      for II := 0 to HH do
      begin
        if ((II mod Step) <> 0) then
          Continue;

        Score := 0;

        X1 := ATPA[I][II].X - (Loc.W / 2);
        Y1 := ATPA[I][II].Y - (Loc.H / 2);
        X2 := ATPA[I][II].X + (Loc.W / 2);
        Y2 := ATPA[I][II].Y + (Loc.H / 2);

        // Go through every TPA again, calculating surrounding color counts.
        for III := 0 to H do
        begin
          tmp_TPA := MSI_ReturnPointsInBox(ATPA[III], IntToBox(X1, Y1, X2, Y2));
          if (Length(tmp_TPA) >= Loc.Counts[III]) then
            Inc(Score);
        end;

        // If there are enough points of all colors, the location has been found.
        if (Score = H) then
        begin
          Result := True;
          X := (X1 + X2) shr 1;
          Y := (Y1 + Y2) shr 1;
          P := Point(X, Y);
          MSI_SubDebug('Found relocation point via color: (' + IntToStr(P.X) + ', ' + IntToStr(P.Y) + ')');
          Exit;
        end;

      end;
    end;
  end;

  // Symbol Search
  if (Loc.Symbol <> '') then
    if FindSymbol(X, Y, Loc.Symbol) then
    begin
      Result := True;
      P := Point(X, Y);
      MSI_SubDebug('Found relocation point via symbol: (' + IntToStr(P.X) + ', ' + IntToStr(P.Y) + ')');
      Exit;
    end;
end;

{******************************************************************************}
{ function MSI_RelocateRef(var p: TPoint; Location, Index: Integer): Boolean;  }
{ By: Coh3n                                                                    }
{ Date: 07 November 2010                                                       }
{ Description: Returns true if point is found, stores it in 'p'                }
{******************************************************************************}
function MSI_RelocateRef(var p: TPoint; Location, Index: Integer): Boolean;
begin
  p := Point(-1, -1);

  if (not LoggedIn) then
    Exit;

  if (Length(MSI_Locations[Location].RelocatePoints) = 0) then
  begin
    MSI_SubDebug('No relocation points for ' + MSI_Locations[Location].Name);
    Exit;
  end;

  {$IFDEF REFLECTION}
    p := TileToMM(MSI_Locations[Location].RelocatePoints[Index]);
    Result := rs_OnMinimap(p.x, p.y);
  {$ENDIF}
end;

{******************************************************************************}
{ function MSI_Relocate(Loc: Integer): Boolean;                                }
{ By: Coh3n & Sir R. Magician                                                  }
{ Date: 03 November 2010                                                       }
{ Description: Returns true if player successfully relocates. If not, will     }
{              switch players/break                                            }
{******************************************************************************}
function MSI_Relocate(Loc: Integer): Boolean;
var
  i: Integer;
  p: TPoint;
begin
  if (not LoggedIn) then
    Exit;

  MSI_AddHeader('MSI_Relocate');

  for i := 0 to High(MSI_Locations[Loc].RelocatePoints) do
  begin
    if (not MSI_RelocateRef(p, Loc, i)) then
      if (not MSI_RelocateColor(p, Loc, i)) then
      begin
        if (i = High(MSI_Locations[Loc].RelocatePoints)) then
          Break;

        Continue;
      end;

    if (Distance(p.x, p.y, MMCX, MMCY) > MSI_Locations[Loc].RelocateDist) then
    begin
      Mouse(p.x, p.y, 4, 4, True);
      MSI_Debug('Walking to Point(' + IntToStr(p.x) + ', ' + IntToStr(p.y) + ')');
      MSI_Flag(0);
      Result := True;
      Break;
    end else
      if (i = High(MSI_Locations[Loc].RelocatePoints)) then
      begin
        MSI_Debug('Already at ' + MSI_Locations[Loc].Name + ' Point['+IntToStr(i)+']');
        Result := True;
      end;
  end;

  MSI_CloseHeader('MSI_Relocate: ' + BoolToStr(Result));
end;



